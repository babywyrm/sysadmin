import argparse
import os,sys,re
from prettytable import PrettyTable

##
##

def parse_nmap_output_file(file_path):
    """
    Parses the nmap output file generated by MAP.py and extracts:
    - Host name
    - TLS versions
    - Ciphers for each TLS version
    """
    results = []
    current_host = None
    current_tls_version = None
    ciphers_for_version = []
    capturing_ciphers = False

    tls_version_regex = re.compile(r"^\|\s+(TLSv\d+\.\d+):$")
    # Matches a line like: "|   TLSv1.2:"
    # group(1) will return "TLSv1.2"

    with open(file_path, "r") as f:
        for line in f:
            line = line.rstrip("\n")

            # Detect host line: "Results for hostname:"
            if line.startswith("Results for "):
                # If we had a previous TLS version in progress, store its results
                if current_host and current_tls_version is not None:
                    results.append((current_host, current_tls_version, ciphers_for_version))

                current_host = line.split("Results for ")[1].strip(":")
                current_tls_version = None
                ciphers_for_version = []
                capturing_ciphers = False
                continue

            # Check if line matches a TLS version line
            tls_match = tls_version_regex.match(line.strip())
            if tls_match:
                # If we were working on a previous TLS version, store it
                if current_host and current_tls_version is not None:
                    results.append((current_host, current_tls_version, ciphers_for_version))

                current_tls_version = tls_match.group(1)
                ciphers_for_version = []
                capturing_ciphers = False
                continue

            # Detect the ciphers: line
            # Example: "|     ciphers:"
            if current_tls_version and "ciphers:" in line:
                capturing_ciphers = True
                continue

            # If we are capturing ciphers, the cipher lines look like:
            # "|       TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256 (ecdh_x25519) - A"
            # Let's strip leading "| " and check if the result starts with "TLS_"
            if capturing_ciphers:
                # Remove leading '| ' characters
                stripped_line = line.lstrip("| ").lstrip()
                # Check if line starts with TLS_
                if stripped_line.startswith("TLS_"):
                    # Extract the cipher name (the first token)
                    parts = stripped_line.split()
                    cipher = parts[0] if parts else None
                    if cipher:
                        ciphers_for_version.append(cipher)
                else:
                    # If line doesn't start with TLS_, we reached the end of cipher lines
                    capturing_ciphers = False

    # After finishing the file, if we had a pending TLS version, store it
    if current_host and current_tls_version:
        results.append((current_host, current_tls_version, ciphers_for_version))

    return results

def main():
    parser = argparse.ArgumentParser(description="Parse nmap ssl-enum-ciphers output into a table.")
    parser.add_argument("input_file", help="Nmap output file generated by MAP.py")
    parser.add_argument("output_file", help="File to store the formatted table")
    args = parser.parse_args()

    if not os.path.isfile(args.input_file):
        print(f"Error: {args.input_file} does not exist.")
        return

    results = parse_nmap_output_file(args.input_file)

    # Create table
    table = PrettyTable()
    table.field_names = ["Host", "TLS Version", "Ciphers"]

    for host, tls_version, ciphers in results:
        if not ciphers:
            ciphers = ["No ciphers found"]
        table.add_row([host, tls_version, "\n".join(ciphers)])

    # Save and print
    with open(args.output_file, "w") as outfile:
        outfile.write(table.get_string())

    print("\nFormatted Results:")
    print(table)

if __name__ == "__main__":
    main()

##
##
