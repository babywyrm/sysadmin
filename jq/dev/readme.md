

https://github.com/stedolan/jq/wiki/Cookbook
<br>
https://stackoverflow.com/questions/50253817/updating-json-object-values-dynamically-and-storing-them-in-a-new-file-in-bash
<br>
https://stackoverflow.com/questions/50487995/converting-text-file-to-json-in-python
<br>
https://unix.stackexchange.com/questions/600789/how-to-set-json-value-with-jq-as-the-result-of-command-piped-to-jq
<br>
<br>

##########
##########

Convert a plain list of timestamps to an array of objects with date and time separated (using jq's --slurp and --raw-input options combined):

cat timestamps.txt | jq --slurp --raw-input 'split("\n")[:-1] | map({
	date: (. | strptime("%a, %d %b %Y %H:%M:%S") | todate[0:10]),
	time: (. | strptime("%a, %d %b %Y %H:%M:%S") | todate[11:19])
})'

############
############

From a plain list of timestamps, count the occurrences of unique days (the first part is from the example above):

split("\n")[:-1] | map({
  date: (. | strptime("%a, %d %b %Y %H:%M:%S") | todate[0:10]),
  time: (. | strptime("%a, %d %b %Y %H:%M:%S") | todate[11:19])
}) | reduce .[] as $item (
  {}; # initial value
  .[$item.date] += 1 # reducer
)

############
############


eval "$(
  curl https://api.github.com/gists/968b8937a153127cfae4a173b6000c1e |
  jq -r '
    .files |
    to_entries |
    .[].value |
    @sh "echo \(.content) > \(.filename)"
  '
)"


############
############

 2287  jq -M --argfile b pets.json '.[0].pets[0] *= $b[0].species[0]' newpets.json
 2290  jq --argfile B pets.json -f combine.jq A.json \n
 2291  jq --argfile a pets.json '[JOIN(INDEX($a[]; .domain); .[]; .domain; add)]' 1.json\n
 2292  jq --argfile a pets.json '[JOIN(INDEX($a[]; .domain); .[]; .domain; add)]' newpets.json\n
 2293  jq --argfile a pets.json '[JOIN(INDEX($a[]; .species); .[]; .domain; add)]' newpets.json\n
 2294  jq --argfile a pets.json '[JOIN(INDEX($a[]; .species); .[]; .species; add)]' newpets.json\n
 2295  jq --argfile a pets.json '[JOIN(INDEX($a[]; .name); .[]; .species; add)]' newpets.json\n
 2296  jq --argfile a pets.json '[JOIN(INDEX($a[]; .name); .[]; .name; add)]' newpets.json\n
 2297  jq --argfile a pets.json '[JOIN(INDEX($a[]; .pets); .[]; .name; add)]' newpets.json\n
 2298  jq --argfile a pets.json '[JOIN(INDEX($a[]; .pets); .[]; .name; pets)]' newpets.json\n
 2312  jq -n --argfile source newpets.json --argfile target pets.json -f filter.jq
 2316  jq -n --argfile source newpets.json --argfile target pets.json -f filter.jq > things.json
 2319  jq -n --argfile source newpets.json --argfile target pets.json -f filter.jq > things.json
 2331  jq -n --argfile source slim.json --argfile target pets.json -f filter.jq > things.json
 2340  jq -n --argfile source slim.json --argfile target pets.json -f filter.jq > things.json
 2343  jq -n --argfile source slim.json --argfile target pets.json -f filter.jq > YO
 2364  jq --argfile b b.json -f update.jq a.json\n
 2365  jq --argfile b b.json -f thing.jq a.json\n
 2366  jq --argfile b pets.json -f thing.jq newpets.json\n
 2370  jq --argfile b pets.json -f thing.jq newpets.json\n
 2372  jq --argfile b pets.json -f thing.jq newpets.json\n
 2376  jq -n --argfile source slim.json --argfile target pets.json -f filter.jq 
 
############
############

<br>
<br>


Here is a snippet of the JSON file to be replaced. The whole file is way too big to be posted here. But the path to the key "name" is ".lab.racks[].nodes[].name"

    "roles": [
           "bla bla",
           "bla bla"
      ],
      "name": "Node1",
       "power": {
       "address": "10.182.149.145",
       "type": "bla bla",
       "user": "bla bla",
       "pass": "bla bla "
       },
The "name": "Node1" must be replaced as "name": "Tom-cat". The name Tom-cat is dynamically generated and changes everytime a Metal as a Service (MaaS) script is run. This name "Tom-cat" and all other new names generated by MaaS is cut (using awk) and stored in a text file newhostnames.txt

The textfile looks like this

#newhostnames.txt
Tom-cat
Lucky-worm
Wom-bat
So the goal is to replace the "name" key from demolabconfig.json with the names stored in the text file.

"name": "Node1" must be replaced as "name":"Tom-cat"
];
.....
.....
],
"name": "Node2" must be replaced as "name":"Lucky-worm"
];
.....
.....
],
"name": "Node3" must be replaced as "name":"Wom-bat"
The indexing is done for the key "nodes": .lab.racks[].nodes[$i].name

The code:

readarray -t array < newhostnames.txt
array=("${array[@]:1}")
array_length=${#array[@]}
for((i=0;i<${array_length};i++));
do
    declare -x  NEW_NODENAME
    OLD_NODENAME=$(jq -r ".lab.racks[].nodes[$i].name" demolabconfig.json)
    echo "$OLD_NODENAME"
    NEW_NODENAME="${array[i]}"
    echo "$NEW_NODENAME"
    jq ".lab.racks[].nodes[$i].name=env.NEW_NODENAME" demolabconfig.json > newdemolabconfig.json
done
But the code only replaces one value in the end for the last $i i.e, the last key_value pair. All other preceding nodes retain the same name as in the original JSON file.

I have tried by using an if statement to break the loop if the value is already updated so it is not re_written from the old demolabconfig.json file. But that is also not working!

if [[ "$OLD_NODENAME" -ne "$NEWNODENAME" ]]; then
    jq ".lab.racks[].nodes[$i].name=env.NEW_NODENAME" demolabconfig.json > newdemolabconfig.json
else
    break
fi
This if loop was written with a while loop instead of for. This replaces the last name with null.

Please suggest how I can fix this error and improve my code. Thanks :)

json
bash
jq
Share
Follow
edited May 9, 2018 at 13:31
asked May 9, 2018 at 12:47
user avatar
Akshatha Nadig
2144 bronze badges
First, -ne is strictly for integer comparison; use != for string comparison. However, you should post a sample input and expected output, as there is almost certainly a way to do this with one call to jq, rather than iterating in bash. (There is a cleaner way to do that iteration in bash, but it's not really on-topic enough here to post as answer. { read; while IFS= read -r new_nodename; do ...; done; } < newhostnames.txt. – 
chepner
 May 9, 2018 at 12:52
Oh, ignore my loop comment; right now, you still need i to match your local array to the JSON array. – 
chepner
 May 9, 2018 at 13:04
Hi, thank you ! I have edited the question, I hope this gives a better picture of what I am trying to accomplish. – 
Akshatha Nadig
 May 9, 2018 at 13:32
Add a comment
2 Answers
Sorted by:

Highest score (default)

1

The goal here should be to call jq as few times as possible. Accordingly, we present a solution which involves just two calls to jq, irrespective of the number of "names" in newhostnames.txt.

First let's suppose input.json contains the following:

{"nodes":[{"name":"old1"},{"name":"old2"},{"name":"old3"}]}
Let's also suppose the follow jq program is in the file program.jq:

  reduce range(0; $newhostnames | length) as $i (.;
    .nodes[$i].name = $newhostnames[$i])
Then the invocation:

jq -c --slurpfile newhostnames <(jq -nR inputs newhostnames.txt ) \
   -f program.jq input.json
produces:

{"nodes":[{"name":"Tom-cat"},{"name":"Lucky-worm"},{"name":"Wom-bat"}]}
(The -c command-line option produces compressed output.)

If your shell does not support the above invocation, you could (for example) put the output of jq -nR inputs newhostnames.txt in a temporary file.

Of course the subsidiary task of converting the .txt file into a JSON array or a stream of JSON strings can be accomplished in other ways.

Robustification
If there's a chance that newhostnames.txt contains unwanted blank lines, then one way to skip them would be to add one line to program.jq so that it would look like this:

($newhostnames | map(select(length>0))) as $newhostnames
| reduce range(0; $newhostnames | length) as $i (.;
      .nodes[$i].name = $newhostnames[$i])
      
      
