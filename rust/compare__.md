
| **Aspect**                    | **Rust**                                                                                                                                             | **C**                                                                                                                                               |
|-------------------------------|------------------------------------------------------------------------------------------------------------------------------------------------------|-----------------------------------------------------------------------------------------------------------------------------------------------------|
| **Memory Safety**             | - Rust enforces memory safety at compile time via its ownership, borrowing, and lifetimes.<br>- No null or dangling pointer by default.            | - C gives direct access to memory via pointers.<br>- No built‑in protection against dangling pointers, buffer overflows, or null dereferences.          |
| **Ownership & Borrowing**     | - Every value has a single owner and the Rust borrow checker ensures that references do not outlive the data.<br>Example:               | - C does not enforce ownership. Manual management of memory leads to potential double frees, use-after-free, or memory leaks.<br>Example:            |
|                               | ```rust                                                                                                                                            | ```c                                                                                                                                               |
|                               | fn take_ownership(s: String) {                                                                                                                      | void take_ownership(char *s) {                                                                                                                     |
|                               |     println!("String: {}", s);                                                                                                                      |     printf("String: %s\n", s);                                                                                                                      |
|                               | }                                                                                                                                                    | }                                                                                                                                                   |
|                               |                                                                                                                                                      |                                                                                                                                                     |
|                               | fn main() {                                                                                                                                         | int main() {                                                                                                                                       |
|                               |     let s = String::from("hello");                                                                                                                 |     char *s = strdup("hello");  // Must free(s) later                                                                                              |
|                               |     take_ownership(s);                                                                                                                               |     take_ownership(s);                                                                                                                              |
|                               |     // s is no longer valid here                                                                                                                     |     free(s);                                                                                                                                       |
|                               | }                                                                                                                                                    |     return 0;                                                                                                                                      |
|                               | ```                                                                                                                                                  | ```                                                                                                                                                 |
| **Null Safety**               | - No concept of a null pointer in safe Rust. Uses `Option<T>` to represent nullable types with compile‑time checks.                                  | - C pointers can be NULL with no compile-time checking, increasing the risk of null dereference errors.                                             |
|                               | Example:                                                                                                                                            | Example:                                                                                                                                             |
|                               | ```rust                                                                                                                                            | ```c                                                                                                                                               |
|                               | fn process_value(val: Option<i32>) {                                                                                                                 | void process_value(int *val) {                                                                                                                      |
|                               |     match val {                                                                                                                                     |     if (val == NULL) {                                                                                                                              |
|                               |         Some(x) => println!("Got: {}", x),                                                                                                           |         printf("Null pointer\n");                                                                                                                  |
|                               |         None => println!("No value"),                                                                                                               |         return;                                                                                                                                    |
|                               |     }                                                                                                                                               |     }                                                                                                                                               |
|                               | }                                                                                                                                                    |     printf("Got: %d\n", *val);                                                                                                                       |
|                               | ```                                                                                                                                                  | }                                                                                                                                                   |
| **Error Handling**            | - Uses the `Result<T, E>` type to encourage explicit error handling. Errors are caught at compile‑time or easily handled via `?` operator.            | - C relies on error codes, manual checks, and sometimes signals – making it easier to ignore errors or introduce security risks if mistakes are made.|
|                               | Example:                                                                                                                                            | Example:                                                                                                                                             |
|                               | ```rust                                                                                                                                            | ```c                                                                                                                                               |
|                               | fn read_file(path: &str) -> Result<String, std::io::Error> {                                                                                        | char* read_file(const char *path) {                                                                                                                 |
|                               |     std::fs::read_to_string(path)                                                                                                                   |     FILE *fp = fopen(path, "r");                                                                                                                     |
|                               | }                                                                                                                                                    |     if (!fp) return NULL;                                                                                                                           |
|                               | ```                                                                                                                                                  |     // ... read file and handle errors manually                                                                                                   |
| **Concurrency & Data Races**  | - Rust’s type system and ownership model prevent data races at compile time.<br>- Concurrency primitives are safe by design.                            | - C allows free‑form multithreading with POSIX threads or similar, but data races are a common source of security issues; unsafe by default.         |
|                               | Example using threads:                                                                                                                              | Example using pthreads:                                                                                                                            |
|                               | ```rust                                                                                                                                            | ```c                                                                                                                                               |
|                               | use std::thread;                                                                                                                                   | #include <pthread.h>                                                                                                                               |
|                               |                                                                                                                                                      | #include <stdio.h>                                                                                                                                 |
|                               | fn main() {                                                                                                                                        | void *thread_fn(void *arg) {                                                                                                                         |
|                               |     let handle = thread::spawn(|| {                                                                                                                 |     printf("Hello from thread\n");                                                                                                                 |
|                               |         println!("Hello from Rust thread");                                                                                                        |     return NULL;                                                                                                                                   |
|                               |     });                                                                                                                                             | }                                                                                                                                                   |
|                               |     handle.join().unwrap();                                                                                                                        | int main() {                                                                                                                                       |
|                               | }                                                                                                                                                    |     pthread_t thread;                                                                                                                              |
|                               | ```                                                                                                                                                  |     pthread_create(&thread, NULL, thread_fn, NULL);                                                                                                 |
|                               |                                                                                                                                                      |     pthread_join(thread, NULL);                                                                                                                     |
|                               |                                                                                                                                                      |     return 0;                                                                                                                                      |
|                               |                                                                                                                                                      | }                                                                                                                                                   |
| **Range & Bounds Checking**   | - Array and slice accesses are checked at runtime in debug builds (and optionally in release builds), reducing buffer overflow risks.                 | - C performs no automatic bounds checking—accessing an array beyond its allocated length leads to undefined behavior and potential exploits.        |
|                               | Example:                                                                                                                                            | Example:                                                                                                                                             |
|                               | ```rust                                                                                                                                            | ```c                                                                                                                                               |
|                               | let arr = [1, 2, 3];                                                                                                                                | int arr[3] = {1, 2, 3};                                                                                                                             |
|                               | println!("Value: {}", arr.get(2).unwrap()); // Safe access                                                                                         | printf("Value: %d\n", arr[2]); // No bounds check                                                                                                   |
|                               | // arr.get(3) would return None, preventing out-of-bound access                                                                                     | // arr[3] is undefined and dangerous                                                                                                               |
|                               | ```                                                                                                                                                  | ```                                                                                                                                                 |
| **Security Advancements**     | - **Immutable by Default:** Variables are immutable unless explicitly declared mutable.<br>- **Safe Concurrency:** No data races without using unsafe code.<br>- **Modern Build Tools:** Cargo manages dependencies and builds with secure defaults. | - **Manual Memory Management:** Requires explicit malloc/free, prone to mistakes.<br>- **Legacy Codebase:** Many security problems arise from legacy unsafe C functions (e.g., strcpy).  |
|                               | - Compiler enforces strict compile-time checks and lifetimes.                                                                                       | - Less built-in protection; relies on developer discipline and external analysis tools (e.g., static analyzers).                                     |
