MurmurHash driven single-use seed-based pseudo-random number generator. And also a Standard Raised Cosine probabilistic distribution-based map.
_rng-murmur-seed-std-raised-cosine.md
This quick Gist shows how to use the fast non-cryptographic hash function MurmurHash to generate a single purely deterministic random numbers based off a of specific seed. 
I'm borrowing the perezd/node-murmurhash NPM port.

The idea is to deterministically recreate the same set of numbers from a small number of seeds with algorithms that internally use these seeds (in any order, note) 
by modifying them with constant but unique salts of their own. MurmurHash is fast enough for use in games (for me).

The other half of this Gist contains a standard form (because the custom bound and mode is pointless with a simple general-purpose map function, and the curvature cannot be varied anyway) of the "Gaussianesque" Raised Cosine Distribution, which is conveniently finite and enough for my example use. It maps uniform random numbers generated by the MurmurHash prng to the mentioned distribution, between 0 to 1 in either case.

##
#
https://gist.github.com/5310/9ffee50db776bdc6ad0e
#
https://gist.github.com/ghafran/8883678
#
##

```
example.js
var seed = "Steve";
var value = rngMap ( rngStdRaisedCosine( rngMurmur( seed+"height" ) ), 4, 7 );
console.log( seed+"'s is "+Math.floor(value)+"'"+Math.round( (value % 1) * 12 )+'" tall.');
murmurhash.js
/* Directly copied from the global and NPM module version at https://github.com/perezd/node-murmurhash for convenience. */

(function(){
  var _global = this;

  /**
   * JS Implementation of MurmurHash2
   *
   * @author <a href="mailto:gary.court@gmail.com">Gary Court</a>
   * @see http://github.com/garycourt/murmurhash-js
   * @author <a href="mailto:aappleby@gmail.com">Austin Appleby</a>
   * @see http://sites.google.com/site/murmurhash/
   *
   * @param {string} str ASCII only
   * @param {number} seed Positive integer only
   * @return {number} 32-bit positive integer hash
   */
  function MurmurHashV2(str, seed) {
    var
      l = str.length,
      h = seed ^ l,
      i = 0,
      k;

    while (l >= 4) {
      k =
        ((str.charCodeAt(i) & 0xff)) |
        ((str.charCodeAt(++i) & 0xff) << 8) |
        ((str.charCodeAt(++i) & 0xff) << 16) |
        ((str.charCodeAt(++i) & 0xff) << 24);

      k = (((k & 0xffff) * 0x5bd1e995) + ((((k >>> 16) * 0x5bd1e995) & 0xffff) << 16));
      k ^= k >>> 24;
      k = (((k & 0xffff) * 0x5bd1e995) + ((((k >>> 16) * 0x5bd1e995) & 0xffff) << 16));

    h = (((h & 0xffff) * 0x5bd1e995) + ((((h >>> 16) * 0x5bd1e995) & 0xffff) << 16)) ^ k;

      l -= 4;
      ++i;
    }

    switch (l) {
    case 3: h ^= (str.charCodeAt(i + 2) & 0xff) << 16;
    case 2: h ^= (str.charCodeAt(i + 1) & 0xff) << 8;
    case 1: h ^= (str.charCodeAt(i) & 0xff);
            h = (((h & 0xffff) * 0x5bd1e995) + ((((h >>> 16) * 0x5bd1e995) & 0xffff) << 16));
    }

    h ^= h >>> 13;
    h = (((h & 0xffff) * 0x5bd1e995) + ((((h >>> 16) * 0x5bd1e995) & 0xffff) << 16));
    h ^= h >>> 15;

    return h >>> 0;
  };

  /**
   * JS Implementation of MurmurHash3 (r136) (as of May 20, 2011)
   *
   * @author <a href="mailto:gary.court@gmail.com">Gary Court</a>
   * @see http://github.com/garycourt/murmurhash-js
   * @author <a href="mailto:aappleby@gmail.com">Austin Appleby</a>
   * @see http://sites.google.com/site/murmurhash/
   *
   * @param {string} key ASCII only
   * @param {number} seed Positive integer only
   * @return {number} 32-bit positive integer hash
   */
  function MurmurHashV3(key, seed) {
    var remainder, bytes, h1, h1b, c1, c1b, c2, c2b, k1, i;

    remainder = key.length & 3; // key.length % 4
    bytes = key.length - remainder;
    h1 = seed;
    c1 = 0xcc9e2d51;
    c2 = 0x1b873593;
    i = 0;

    while (i < bytes) {
        k1 =
          ((key.charCodeAt(i) & 0xff)) |
          ((key.charCodeAt(++i) & 0xff) << 8) |
          ((key.charCodeAt(++i) & 0xff) << 16) |
          ((key.charCodeAt(++i) & 0xff) << 24);
      ++i;

      k1 = ((((k1 & 0xffff) * c1) + ((((k1 >>> 16) * c1) & 0xffff) << 16))) & 0xffffffff;
      k1 = (k1 << 15) | (k1 >>> 17);
      k1 = ((((k1 & 0xffff) * c2) + ((((k1 >>> 16) * c2) & 0xffff) << 16))) & 0xffffffff;

      h1 ^= k1;
          h1 = (h1 << 13) | (h1 >>> 19);
      h1b = ((((h1 & 0xffff) * 5) + ((((h1 >>> 16) * 5) & 0xffff) << 16))) & 0xffffffff;
      h1 = (((h1b & 0xffff) + 0x6b64) + ((((h1b >>> 16) + 0xe654) & 0xffff) << 16));
    }

    k1 = 0;

    switch (remainder) {
      case 3: k1 ^= (key.charCodeAt(i + 2) & 0xff) << 16;
      case 2: k1 ^= (key.charCodeAt(i + 1) & 0xff) << 8;
      case 1: k1 ^= (key.charCodeAt(i) & 0xff);

      k1 = (((k1 & 0xffff) * c1) + ((((k1 >>> 16) * c1) & 0xffff) << 16)) & 0xffffffff;
      k1 = (k1 << 15) | (k1 >>> 17);
      k1 = (((k1 & 0xffff) * c2) + ((((k1 >>> 16) * c2) & 0xffff) << 16)) & 0xffffffff;
      h1 ^= k1;
    }

    h1 ^= key.length;

    h1 ^= h1 >>> 16;
    h1 = (((h1 & 0xffff) * 0x85ebca6b) + ((((h1 >>> 16) * 0x85ebca6b) & 0xffff) << 16)) & 0xffffffff;
    h1 ^= h1 >>> 13;
    h1 = ((((h1 & 0xffff) * 0xc2b2ae35) + ((((h1 >>> 16) * 0xc2b2ae35) & 0xffff) << 16))) & 0xffffffff;
    h1 ^= h1 >>> 16;

    return h1 >>> 0;
  }

  var murmur = MurmurHashV3;
  murmur.v2 = MurmurHashV2;
  murmur.v3 = MurmurHashV3;

  if (typeof(module) != 'undefined') {
    module.exports = murmur;
  } else {
    var _previousRoot = _global.murmur;
    murmur.noConflict = function() {
      _global.murmur = _previousRoot;
      return murmur;
    }
    _global.murmur = murmur;
  }
}());
rng-map.js
var rngMap = function( x, a, b ) {
    return a + ( b - a ) * x;
};
rng-standard-raised-cosine.js
var rngStdRaisedCosine = function( x ) {
    // Standard version with mu = s = 0.5
    // pdf: con(PI*(2*x-1)) + 1
    // cdf: ( sin(PI*(2*x-1)/2) + 1 ) / 2
    // inverse cdf: ( PI - 2*asin(1-2*x) ) / 2*PI
    return ( Math.PI - 2 * Math.asin( 1 - 2 * x ) ) / ( 2 * Math.PI );
};
```



MurmurHashV3.sql
```
DROP FUNCTION IF EXISTS MurmurHashV3;
DELIMITER //
CREATE FUNCTION `MurmurHashV3`(`keyx` varchar(65535), `seed` int unsigned)
	RETURNS int unsigned
BEGIN
	DECLARE remainder,bytes,c1,c2,i, m1,m2 INT unsigned;
	DECLARE h1,k1,h1b BIGINT unsigned;
	SET remainder = LENGTH(keyx) & 3;
	SET bytes = LENGTH(keyx) - remainder;
    SET h1 = seed;
    SET c1 = 0xcc9e2d51;
    SET c2 = 0x1b873593;
    SET m1 = 0x85ebca6b, m2 = 0xc2b2ae35;
    SET i = 1;

    WHILE i <= bytes DO
       set k1 = ( ascii(mid(keyx,i,1)) & 0xff ) | 
		((ascii(mid(keyx,i+1,1)) & 0xff) << 8) |
		((ascii(mid(keyx,i+2,1)) & 0xff) << 16) |
		((ascii(mid(keyx,i+3,1)) & 0xff) << 24);
      set i = i + 4;

      set k1 = (k1*c1) & 0xffffffff;
      set k1 = ((k1 << 15) | (k1 >> 17))& 0xffffffff;
      set k1 = (k1*c2) & 0xffffffff;

      set h1 = h1 ^ k1;
      set h1 = ((h1 << 13) | (h1 >> 19))& 0xffffffff;
      set h1b = (h1*5) & 0xffffffff;
      set h1 = (h1b+0xe6546b64)& 0xffffffff;
    END WHILE;

    SET k1 = 0;

   IF remainder>=3  THEN SET k1 = k1^((ascii(mid(keyx,i + 2,1)) & 0xff) << 16); END IF;
	IF remainder>=2 THEN SET k1 = k1^((ascii(mid(keyx,i + 1,1)) & 0xff) << 8); END IF;
	IF remainder>=1 THEN SET k1 = k1^(ascii(mid(keyx,i,1)) & 0xff);
      set k1 = (k1*c1) & 0xffffffff;
      set k1 = ((k1 << 15) | (k1 >> 17))& 0xffffffff;
      set k1 = (k1*c2) & 0xffffffff;
      set h1 = h1 ^ k1;
    END IF;

	 set h1 = h1 ^ LENGTH(keyx);
    set h1 = h1 ^ (h1 >> 16);
	 set h1 = (h1*m1) & 0xffffffff;
    
	 set h1 = h1 ^ (h1 >> 13);
    set h1 = (h1*m2) & 0xffffffff;
    set h1 = h1 ^ (h1 >> 16);

    return h1;
END;//
DELIMITER ;
```

Select MurmurHashV3('test', 0);
@allan-simon
allan-simon commented on Mar 19, 2016
note that it pop warning if your database is in UTF-8 as the varchar(65535) exceed the maximun number of bytes of a varchar (as then you have potentially 65535 characters of 3 bytes each)
and it does not work as expected if you feed it with utf-8 encoded string (as the mid methods will cut by characters of potentially 3 bytes while you're expecting in murmur hash to iterate byte by byte)

I've created a corrected version (which we have tested to produce exactly the same 32 bit hashes as python module mmh3)
http://allan-simon.github.io/blog/posts/murmur_hash_v3_in_mysql_utf8_compatible/
